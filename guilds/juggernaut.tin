#nop juggernaut.tin
/*
	Based on Inix's original jugger file.

	Getting started:
		Type juggsetmeup to set the required defaults.

	Jugger Settings
		Use the jset command (jset help) to configure guild options, such as powers on/off if you have/dont have access,
		ammo details, etc.

	Mech Configuration
		Use the mech command (mech help) to create mech profiles and switch between them.

	Suit Loadouts
		Use the suit command (if you have one of the the suit reset VAFs) to load all your levels, techs, mounts, etc.
		Only use the 'suit load' command after you have reset your GXP, switched to the suit you want and salvaged GXP.

	Commands:
		jset	 - Configuration tool, see 'jset help' for more information.
		mech	 - Mech loadout tool. See 'mech help' for more information.
		suit	 - Suit loadout tool. See 'suit help' for more information.
		jdmg	 - Juggernaut damage tracker for physical, mount, tank and point defenses dmg. jdmg clear to clear.
		gxp		 - Gxp tracking, gxp reset to clear.
		sdef	 - Toggle or turn on support auto defending.
		stimheal - Find a corpse and deener it.
		kill	 - Overrides mud kill to provide support for a delay when mech tanking and using flipbird in its place.
		tgo		 - WIP - drive your truck to roomnotes.
		mammo	 - Missile ammo swap tool. Results may vary if you do not have access to all the ammo types.
		 	 		mammo			- display the list of ammo types
	 				mammo poison	- swap your ammo type to biotech ammo (8) for the next reload
 					mammo fire d	- swap your ammo type to fire (default, 6) and dump remaining ammo for an immediate change
		pammo	 - As above but for projectile mounts.
*/
#class {juggernautmech} {kill}
#class {juggernaut} {kill}
#class {juggersettings} {kill}
#class {juggernaut} {open}

#read {.tt/3k/guilds/juggernaut_mech.tin}
#read {.tt/3k/guilds/juggernaut_suit.tin}

#variable {guild} {juggernaut}
#variable {clan} {0}
#variable {nukes} {0}
#variable {reset} {0}
#variable {rod} {0}
#variable {scol} {<bbb>}
#variable {path_len} {0}
#variable {path_pos} {0}
#variable {flipbirdkill} {0}
#variable {pfocus} {0}
#variable {gxprounds} {0}
#variable {gxptotal} {0}
#variable {gxpaverage} {0}
#variable {jdamage} {}
#variable {jdamage_rounds} {0}
#variable {support_switching} {0}
#variable {mountcolour} {}
#variable {mount_crit} {0}
#variable {frenzied} {0}

#gag {^Your jumpjets ignite}
#gag {^ nutrients out of it.}
#gag {^Your feral rage allows you to shrug}
#gag {^The box doesn't want that...}
#gag {^Sakhan. This should probably be donated}
#gag {^Your guild prevents you from doing that.}
#gag {^Too many of those already to get credit.}
#gag {^The computer chirps 'Heat sinks are erratic!!'}

#substitute {^Tank attaches a hose to a corpse and sucks the} {Your tank attaches a hose to a corpse and sucks the nutrients out of it.}

#alias {boxall} {put all in box;boxbpall}
#alias {sellall} {sell all;sellbpall}
#alias {donateall} {donate all;donatebpall}
#alias {gwho} {juggs}
#alias {gwho2} {juggs2}
#alias {ff} {fire $nukes}
#alias {i} {jinv}
#alias {cr} {creport}
#alias {ap} {analyze plating}
#alias {kt1} {ktrig wrap/enhance/deener/truck deener/fdeener}
#alias {mload} {#read {.tt/3k/guilds/juggernaut_mech.tin}}
#alias {cd}  {cdefend}
#alias {cds} {cdefend show}
#alias {cdp} {cdefend party;#delay {2} {cdm}}
#alias {cdm} {cdefend ${ses_name}mech}
#alias {k} {kill}
#alias {fb} {#if {"%1" == ""} {#send !flipbird all} {#send !flipbird %0}}
#alias {ak} {flipbird all}
#alias {pf} {pfocus 1}
#alias {kr} {retarget}

#alias {ts} {truck status}
#alias {td} {truck drive}
#alias {tl} {truck look}
#alias {tb} {truck block}
#alias {tg} {truck get}
#alias {tp} {truck pfocus}

#alias {suitg} {suit swap gnomeprjmax}
#alias {suits} {suit swap sallyprjmax}

#variable {jthemes} {
	{default}
	{
		{lines}{<cea>}
		{headings}{<dfa>}
		{subheadings}{<cea>}
		{slabels} {<bbb>}
	}
	{magenta}
	{
		{lines}{<eae>}
		{headings}{<faf>}
		{subheadings}{<eae>}
		{slabels} {<bbb>}
	}
}

#nop run this alias when you first start, or need to reset to ansi/hpbar settings
#alias {juggsetmeup}
{
	#send !hp set HP[$HP$] SP[$SP$] S[$STIM$] TS[$TSTIM$] HE[$HEAT$] HT[$HITS$] M/C[$NUKES$/$MNUKES$][$CP$/$MCP$][$RESET$] $N$Ammo[$AMMO$] SHP[$SHP$] SM[$SMD$] SA[$SMF$] SD[$SAF$] G[$GXP$];
	#send !aset jugg_mount_pref -JM-;
	#send !aset jugg_mount_suff -JM-;
	#send !aset jugg_pdeff_pref -JP-;
	#send !aset jugg_pdeff_suff -JP-
}

#alias {fbk}
{
	#if {"%1" == "on" || ("%1" == "" && $flipbirdkill == 0)} {
		#variable {flipbirdkill} {1};
		#echo {<258>Flipbird all will now replace your kill command.<088>}
	} {
		#variable {flipbirdkill} {0};
		#echo {<258>You will no longer flipbird all in place of your kill command.<088>}
	}
}
#alias {kill}
{
	#if {"$support[mode]" == "De" && "$jset[supportkdelay]" == "on"} {
		#delay {2} {#send !kill %0}
	} {
		#if {$flipbirdkill} {
			#send !flipbird all
		} {
			#send !kill %0
		}
	}
}

#alias {dpon}
{
	#variable {dungeon_prep} {1};
	#echo {<258>Dungeon prep is now <158>enabled.<088>}
}

#alias {dpoff}
{
	#variable {dungeon_prep} {0};
	#echo {<258>Dungeon prep is now <158>disabled.<088>}
}

#alias {gxp}
{
	#if {"%1" == ""} {
		#echo {<258>Your gxp average for the last <158>${gxprounds}<258> rounds is <158>${gxpaverage}<258>.<088>}
	};
	#elseif {"%1" == "reset" || "%1" == "clear"} {
		gxp;
		#delay {0.1} {
			#echo {<258>Gxp data has been cleared.<088>};
			#variable {gxprounds} {0};
			#variable {gxptotal} {0};
			#variable {hitsgxp} {}
		}
	};
	#else {
		#echo {<258>Use  <158>gxp<258> to show your average gxp and <158>gxp reset<258> to reset the data.<088>};
	}
}

#alias {stimheal}
{
	#if {$corpses[inventory] > 0} {
		#math {corpses[inventory]} {$corpses[inventory] - 1};
		#send !drop corpse;
		#send !fdeener
	}; #elseif {$corpses[truck] > 0} {
		#send !get corpse from $jset[truckname];
		#math {corpses[truck]} {$corpses[truck] -1};
		#send !fdeener
	}; #elseif {$corpses[freezer] > 0} {
		#send !deslab;
		#send !fdeener
	}; #elseif {$corpses[cooler] > 0} {
		#send !uncooler corpse;
		#send !fdeener
	}; #elseif {$corpses[coffin] > 0} {
		#send !unwrap;
		#send !fdeener
	}; #else {
		#if {"$bot" == "1"} {.stop};
		#bell
	}
}

#action {^You fly into a feral rage}
{
	#variable {frenzied} {1}
}

#action {^The rage subsides.}
{
	#variable {frenzied} {0}
}

#action {^%w calls upon %w and mends you from afar.}
{
	update_chat %0
}

#action {^The computer chirps 'Auto defending %w}
{
	#local {ldefend} {%1};
	#format {ldefend} {%l} {$ldefend};
	#if {"$ldefend" != "$ses_name"} {
		#nop cassist seems to help with the initial hits with cdefend;
		cassist $ldefend
	}
}

#action {^The computer chirps 'Alternate fire mode %1 for mount number 1'}
{
	#if {"%1" == "activated"} {
		#variable {pfocus} {1}
	} {
		#variable {pfocus} {0}
	}
}

#alias {jdmg}
{
	#if {"%1" == "reset"} {
		#variable {jdamage} {};
		#variable {jdamage_rounds} {0}
	} {
		#draw $jthemes[$jset[theme]][lines] scroll line 1 1 1 70;
		#echo {$jthemes[$jset[theme]][headings]Source            Hits  Fails  Hit Avg  Rnd Avg  Max Hit  Total Damage<088>};
		#draw $jthemes[$jset[theme]][lines] scroll line 1 1 1 70;
		#foreach {$jdamage} {jdmg} {
			#echo {%-14s<088>  %+6g  %+5g  %+7g  %+7g  %+7g  %+12g} {$jdmg} {$jdamage[$jdmg][hits]} {$jdamage[$jdmg][fail]} {$jdamage[$jdmg][avghit]} {$jdamage[$jdmg][avground]} {$jdamage[$jdmg][max]} {$jdamage[$jdmg][total]};
		};
		#draw $jthemes[$jset[theme]][lines] scroll line 1 1 1 70;
		#echo {Recorded over %d rounds of combat.} {$jdamage_rounds};
	}
}

#function {recordjdmg}
{
	#nop %1 == name, %2 == value;
	#math {jdamage[%1][hits]} {$jdamage[%1][hits] +1};
	#math {jdamage[%1][total]} {$jdamage[%1][total] + %2};

	#variable {jdamage[%1][last]} {%2};

	#if {"$jdamage[%1][max]" == ""} {
		#variable {jdamage[%1][max]} {%2}
	};#elseif {%2 > $jdamage[%1][max]} {
		#variable {jdamage[%1][max]} {%2}
	};

	#math {jdamage[%1][avghit]} {$jdamage[%1][total] / $jdamage[%1][hits]};
	#math {jdamage[%1][avground]} {$jdamage[%1][total] / $jdamage_rounds};

	#variable result { }
}

#function {recordjdmgfail}
{
	#nop %1 == name, %2 == value;
	#math {jdamage[%1][fail]} {$jdamage[%1][fail] +1};
	#variable result { }
}

#action {^The runesword emits a yellow glow as it causes you to strike again!}
{
	#nop @recordjdmg{yellow rune;0}
}

#action {wound causes %* to shudder in pain. \{%d\}$}
{
	#nop @recordjdmg{green rune;%2}
}

#action {^Bolts of blue electricity leap from the blade and strike %*! \{%d\}}
{
	#nop @recordjdmg{blue rune;%2}
}

#action {^You try to jump on}
{
	#line gag;
	#variable {physline1} {%0};
	@recordjdmgfail{jump attack};
}

#action {^You try to punch}
{
	#line gag;
	#variable {physline1} {%0};
	@recordjdmgfail{punch};
}

#action {^You try to kick}
{
	#line gag;
	#variable {physline1} {%0};
	@recordjdmgfail{kick};
}

#action {{^You (kick|punch|jump attack) (?:.*) for (?:[a-z\s]+) damage. \{(\d+)\}}}
{
	#line gag;
	#variable {physline1} {%0};
	@recordjdmg{%2;%3}
}

#action {%* failed to acquire a lock.}
{
	#line gag;
	#math {jdamage_rounds} {$jdamage_rounds +1};
	@recordjdmgfail{mount};
	#variable {mountline1} {<${jset[mountfcolour]}>%0<088>}
}

#action {^The computer chirps 'A critical hit was scored!'}
{
	#if {"$jset[showcrits]" == "off"} {
		#line gag
	};
	#variable {mount_crit} {1};
	#variable {mountcolour} {$jset[critcolour]}
}

#action {^The computer chirps 'Pumping}
{
	#if {"$jset[showenhance]" == "off"} {
		#line gag
	}
}

#action {{^-JM-([\w\s'-.]*)(?:\{([0-9]+)\}-JM-)?}}
{
	#line gag;
	#if {"%3" != ""} {
		#nop complete line with -JM- on the end;
		#regexp {%2} {our tank} {
			#nop it's a tank hit;
			@recordjdmg{tank;%3};
			#variable {tankline1} {<${jset[tankcolour]}>%2{%3}<088>};
		} {
			#nop it's a mount hit;
			#math {jdamage_rounds} {$jdamage_rounds +1};
			#if {$mount_crit} {
				@recordjdmg{mount critical;%3}
			} {
				@recordjdmg{mount normal;%3}
			};
			@recordjdmg{mount total;%3};
			#variable {mountline1} {<${mountcolour}>%2{%3}<088>}
		}
	} {
		#nop the line has wrapped so capture and process on the next line;
		#variable {unknownline1} {%2}
	}
} {1}

#nop only one action can trigger per line, so the unwrapped start, or complete line will take precedence
#nop this action will capture the second, wrapped line
#action {{^([\w\s'-.]*)?\{([0-9]+)\}-JM-$}}
{
	#line gag;
	#variable {$unknownline1} {$unknownline1 %2};
	#regexp {$unknownline1} {our tank} {
		#nop it's a tank hit;
		@recordjdmg{tank;%3};
		#variable {tankline1} {<${jset[tankcolour]}>$unknownline1 {%3}<088>}
	} {
		#nop it's a mount hit;
		#math {jdamage_rounds} {$jdamage_rounds +1};
		#if {$mount_crit} {
			@recordjdmg{mount critical;%3}
		} {
			@recordjdmg{mount normal;%3}
		};
		@recordjdmg{mount total;%3};
		#variable {mountline1} {<${mountcolour}>$unknownline1 {%3}<088>}
	}
} {2}

#action {{^-JP-([\w\s'-.]*)(?:\{([0-9]+)\}-JP-)?}}
{
	#line gag;
	#if {"%3" != ""} {
		#nop complete line with -JP- on the end;
		@recordjdmg{point defense;%3};
		#variable {pdline1} {<${jset[pdcolour]}>%2{%3}<088>}
	} {
		#nop the line has wrapped so capture and process on the next line;
		#variable {unknownline2} {%2}
	}
} {1}

#nop only one action can trigger per line, so the incomplete start, or complete line will take precedence
#nop this action will capture the second, wrapped line
#action {{^([\w\s'-.]*)?\{([0-9]+)\}-JP-$}}
{
	#line gag;
	#variable {$unknownline2} {$unknownline2 %2};
	@recordjdmg{point defense;%3};
	#variable {pdline1} {<${jset[pdcolour]}>$unknownline2 {%3}<088>}
} {2}

#action {{^(?:.*)'s Jugger Support Mech fires at (.*) and (.*)\.(?: \{([0-9]+)\})?}}
{
	#variable {mobname} {%2};
	#math {mechhits} {$mechhits + 1};

	#if {"%4" != ""} {
		#nop player has numbers;
		#if {"$jset[supportbrief]" == "on"} {#line gag};		
		#math {mechdmg} {$mechdmg + %4}
	} {
		#if {"$jset[supportbrief]" == "on"} {
			#nop for some reason could not get a switch statement to work;
			#nop not a yet a complete list of dmg messages;
			#if {"%3" == "did no damage"} {
				#nop no aggregation;
				#line gag
			};
			#elseif {"%3" == "did solid damage"} {
				#math {mechdmgv[solid]} {$mechdmgv[solid] + 1};
				#line gag
			};
			#elseif {"%3" == "did light damage"} {
				#math {mechdmgv[light]} {$mechdmgv[light] + 1};
				#line gag
			};
			#elseif {"%3" == "caused moderate wounds"} {
				#math {mechdmgv[moderate]} {$mechdmgv[moderate] + 1};
				#line gag;
			};
			#elseif {"%3" == "did heavy damage"} {
				#math {mechdmgv[heavy]} {$mechdmgv[heavy] + 1};
				#line gag
			};
			#elseif {"%3" == "did very heavy damage"} {
				#math {mechdmgv[very heavy]} {$mechdmgv[very heavy] + 1};
				#line gag
			};
			#elseif {"%3" == "did some damage"} {
				#math {mechdmgv[some]} {$mechdmgv[some] + 1};
				#line gag
			};
			#elseif {"%3" == "was barely effective"} {
				#math {mechdmgv[barely]} {$mechdmgv[barely] + 1};
				#line gag
			};
			#elseif {"%3" == "did minimal damage"} {
				#math {mechdmgv[minimal]} {$mechdmgv[minimal] + 1};
				#line gag
			};
			#elseif {"%3" == "created a bone crushing sound"} {
				#math {mechdmgv[bone crushing]} {$mechdmgv[bone crushing] + 1};
				#line gag
			};
			#else {
				#nop no gag;
			}			
		}
	}
}

#action {^\[\{MISSILES\}\] %* has locked onto}
{
	#if {"$jset[nukedonate]" == "on"} {
		#${nukes} fire
	}
}

#nop xcore - launch missile when someone adds their payload
#action {^The missile whirrs as it accepts %*'s payload.}
{
	#send !get missile;
	#send !launch $mobname
}

#variable {areasetup}
{
	{tol2} 		{{rune} {demon}}
	{mahjongg}	{{rune} {demon}}
	{carebears}	{{rune} {demon}}
}

#alias {guildcleanup}
{
	#if {"$jset[rod]" == "on"} {
		#send !touch angel rune;
	};
	#if {$combat_que_module} {
		rate 0
	};
	fbk off;
	..
}

#alias {guildsetup}
{
	.stop;

	#if {$dungeon_prep} {
		ptell dungeons?
	} {
		dungeons
	};

	#if {$combat_que_module} {rate run};
	#if {$scalers_module} {scaler run};

	#if {"$jset[rod]" == "on"} {
		#if {"$areasetup[$bots[stepper]][rune]" != ""} {
			#send !touch $areasetup[$bots[stepper]][rune] rune
		} {
			#send !touch angel rune
		}
	};

	#nop append this to the botpath to cleanup at the end of the dungeon;
	#path insert guildcleanup;

	#nop trigger .resume from examining the satchel to allow things to catch up;
	#if {$dungeon_prep} {
		#delay {6} {#send !examine house keys}
	} {
		#delay {2} {#send !examine house keys}
	}
}

#nop from examine house keys in guildsetup - allows the mud text to catch up
#action {^A ring that holds the keys to houses that you have access to}
{
	ctp;

	#switch {"$bots[stepper]"} {
		#case "treehouse_blue" {
			#nop allow stepper vacuum to pickup the hammer;
			ctd;
			#if {$dungeon_prep} {n;s;ptell come n}
		};
		#case "treehouse" {
			#if {$dungeon_prep} {n;s;ptell come n}
		};
		#case "sectionz" {
			#if {$dungeon_prep} {press start;pause game;play;ptell press start}
		};
		#case "sectionz_short" {
			#if {$dungeon_prep} {press start;pause game;play;ptell press start}
		};
		#case "mahjongg" {
			#if {$dungeon_prep} {n;s;ptell come n}
		};
		#case "trans" {
			#if {$dungeon_prep} {n;s;ptell come n}
		};
		#case "aegis" {
			#if {$dungeon_prep} {e;w;ptell come e}
		};
		#case "banshee_lair" {
			#if {$dungeon_prep} {enter;exit;ptell come enter}
		};
		#case "rim2" {
			#if {$dungeon_prep} {e;w;ptell come e}
		}
	};

	#if {$dungeon_prep} {
		#if {$bot == 1} {#delay {4} {.resume}}
	} {
		#if {$bot == 1} {#delay {1} {.resume}}
	}
}

#action {^%1 pokes you in the ribs}
{
	#if {$corpses[inventory] > 0} {
		#math {corpses[inventory]} {$corpses[inventory] - 1};
		#send !drop corpse;
	}; #elseif {$corpses[truck] > 0} {
		#send !get corpse from $jset[truckname];
		#math {corpses[truck]} {$corpses[truck] -1};
		#send !drop corpse
	}; #elseif {$corpses[freezer] > 0} {
		#send !deslab
	}; #elseif {$corpses[cooler] > 0} {
		#send !uncooler corpse
	}; #elseif {$corpses[coffin] > 0} {
		#send !unwrap
	}
}

#alias {tgo}
{
	#variable {truck_dirs} {};

	#path {save} {temp_path};
	#path {get} {position} {temp_pos};

	#map {find} {{roomnote} {%0%*}};
	#path {save} {truck_path};

	#path {load} {$temp_path};
	#path {goto} {$temp_pos};
		
	#list {truck_path} {create} {$truck_path};
	#var truck_path;

	#math i 2;
	#while {&truck_path[+$i]} {
		#send !truck drive $truck_path[+$i];
		#variable {truck_dirs} {$truck_dirs;$truck_path[+$i]};
		#math i $i + 3
	};
	
	#echo {Truck Dirs: $truck_dirs};
	#send !truck look;
}

#action {HP\[%d/%d\] SP\[%d/%d\] S\[%d\] TS\[%d\] HE\[%d\] HT\[%d\] M/C\[%d/%d\]\[%d/%d\]\[%d\]}
{
	#if {"$jset[hpbar]" == "off"} {
		#line gag
	};
	#var {my[hp][current]} {%1};
	#var {my[hp][max]} {%2};
	#var {my[sp][current]} {%3};
	#var {my[sp][max]} {%4};
	#var {my[gp1][current]}	{%5};
	#var {my[gp1][truck]}	{%6};
	#var {my[gp2][current]}	{%7};
	#var {hits}	{%8};
	#var {nukes} {%9};
	#var {nukes_max} {%10};
	#var {clan}	{%11};
	#var {clan_max}	{%12};
	#var {reset} {%13};
	
	#math {my[hp][perc]} {$my[hp][current] * 100 / $my[hp][max]};
	#math {my[sp][perc]} {$my[sp][current] * 100 / $my[sp][max]};

	#if {"$jset[trans]" == "on" && $my[gp1][current] < $jset[transpc] && $my[sp][current] > 50} {
		#if {$my[gp2][current] > 70} {#send !dissipate};
		#send !transpose max
	};

	#nop refill stim from truck;
	#if {$my[gp1][current] < 95 && $my[gp1][truck] > 0} {
		#send !truck transfer
	};

	#nop refill stim from corpses;
	#if {$my[gp1][current] < 50} {
		stimheal
	};

	#nop replenish sp from rolm spark rune if SP is low;
	#if {"$jset[rod]" == "on" && $rolm[charges] > 20} {
		#if {$my[sp][current] < 500} {
			#send !touch spark rune
		}
	};

	#if {$reset >= 95 && $mip[round]} {
		#if {$nukes > 0} {
			#send !fire $nukes
		}
	};

	#if {"$jset[brief]" == "off"} {
		#if {"$pdline1" != ""} {
			#echo {$pdline1};
			#variable {pdline1} {}
		};
		#if {"$tankline1" != ""} {
			#echo {$tankline1};
			#variable {tankline1} {}
		};
		#if {"$physline1" != ""} {
			#echo {<%s>%s<088>} {$jset[physcolour]} {$physline1};
			#variable {physline1} {}
		};
		#if {"$mountline1" != ""} {
			#echo {$mountline1};
			#variable {mountline1} {}
		};
		#if {"$jset[supportbrief]" == "on"} {
			#if {$mechhits > 0} {
				#if {$mechdmg > 0} {
					#nop numbers vaf - display the real dmg amount;
					#echo {<$jset[mechcolour]>Your mech fires at %s %s times for %s damage.<088>} {$mobname} {$mechhits} {$mechdmg}
				} {
					#nop no numbers vaf - display a summary of the hits;
					#if {"$mechdmgv" == ""} {
						#echo {<$jset[mechcolour]>Your mech fires at %s but fails to inflict any damage.<088>} {$mobname}
					} {
						#local {mechdmgvs} {};						
						#foreach {*mechdmgv[%*]} {dmess} {
							#if {"$mechdmgvs" == ""} {
								#variable {mechdmgvs} {${dmess}(${mechdmgv[$dmess]})}
							} {
								#variable {mechdmgvs} {$mechdmgvs, ${dmess}(${mechdmgv[$dmess]})}
							}
						};
						#echo {<$jset[mechcolour]>Your mech fires at %s for %s damage.<088>} {$mobname} {$mechdmgvs}
					}
				}
			}
		}
	} {
		#if {$jdamage[kick][last] > 0} {
			#variable {jdmgphys} {$jdamage[kick][last]}
		};#elseif {$jdmg[punch][last] > 0} {
			#variable {jdmgphys} {$jdamage[punch][last]}
		};#elseif {$jdamage[jump attack][last] > 0} {
			#variable {jdmgphys} {$jdamage[jump attack][last]}
		};#else {
			#variable {jdmgphys} {0}
		};
 		#echo {<dfa>[Attacks]<088>[<%s>%+6g<088>][<%s>%+6g<088>][<%s>%+6g<088>][<%s>%+6g<088>][<%s>%+6g<088>]} {$jset[pdcolour]} {$jdamage[point defense][last]} {$jset[physcolour]} {$jdmgphys} {$jset[tankcolour]} {$jdamage[tank][last]} {$mountcolour} {$jdamage[mount total][last]} {$jset[mechcolour]} {$mechdmg}
	};

	@recordjdmg{support;$mechdmg};

	#variable {mountcolour} {$jset[mountcolour]};
	#variable {mount_crit} {0};
	#variable {mechhits} {0};
	#variable {mechdmg} {0};
	#variable {mechdmgv} {};

	#variable {jdamage[tank][last]} {0};
	#variable {jdamage[mount total][last]} {0};
	#variable {jdamage[jump attack][last]} {0};
	#variable {jdamage[kick][last]} {0};
	#variable {jdamage[punch][last]} {0};
	#variable {jdamage[point defense][last]} {0};
		
	#nop get the bot step position and length for displaying on the bottom bars;
	#path get length path_len;
	#path get position path_pos
}

#action {{Ammo\[(\d+)?\/?(\d+)?\/?(\d+)?/?(\d+)?\/?(\d+)?\] SHP\[\s*(\d+)\] SM\[(\w+)\] SA\[([a-zA-Z\s]+)\] SD\[([a-zA-Z\s]+)\] G\[([\d\.]+)\]}}
{
	#if {"$jset[hpbar]" == "off"} {
		#line gag;
	};
	#var {ammo[1]}		{%2};
	#var {ammo[2]}		{%3};
	#var {ammo[3]}		{%4};
	#var {ammo[4]}		{%5};
	#var {ammo[5]}		{%6};
	#var {support[hp]}	{%7};
	#var {support[mode]}	{%8};
	#var {support[assault]}	{%9};
	#var {support[defend]}	{%10};
	#var {gxp} {%11};

	#math {gxpdelta} {$gxp - $gxplast};
	#variable {gxplast} {$gxp};

	#math {gxprounds} {$gxprounds + 1};
	#math {gxptotal} {$gxptotal + $gxpdelta};
	#math {gxpaverage} {$gxptotal / $gxprounds};
	#format {ammo_len} {%L} {$ammo};

	#if {"$jset[ammobuy]" == "on" && $ammo_len > 0} {
		#if {$ammo[1] < $jset[ammomin]} {
			#send !truck ammo vbuy $jset[mounttype] $jset[ammotype] 1 $jset[ammoamount]
		}; #elseif {$ammo[2] < 100} {
			#send !truck ammo vbuy $jset[mounttype] $jset[ammotype] 2 $jset[ammoamount]
		}; #elseif {$ammo[3] < 100} {
			#send !truck ammo vbuy $jset[mounttype] $jset[ammotype] 3 $jset[ammoamount]
		}; #elseif {$ammo[4] < 100} {
			#send !truck ammo vbuy $jset[mounttype] $jset[ammotype] 4 $jset[ammoamount]
		}; #elseif {$ammo[5] < 100} {
			#send !truck ammo vbuy $jset[mounttype] $jset[ammotype] 5 $jset[ammoamount]
		}
	};

	#if {"$jset[support]" == "on"} {
		#nop dismiss the support if it's near death OR;
		#nop it's near reset and the health is below another threshhold, but only if we are not already switching;
		#nop support_switching - 1 if the support is being dismissed and summoned;
		#nop support_defended  - 1 if the support has defended you this fight;

		#nop check to see if we have been hit for the last two rounds;
		#variable {hits_prev} {$hits_this};
		#variable {hits_this} {$hits};
		#if {$htis_prev > 0 && $hits_this > 0} {#variable {gotaggro} {1}} {#variable {gotaggro} {0}};

		#if {$support[hp] > 0} {
			#if {($support[hp] < $jset[supportminhp] && $clan > 0) || ($reset >= 95 && $support[hp] < 50 && $clan > 0 && $support_switching == 0)} {
				#if {"$jset[supportdefend]" == "on"} {
					#variable {support_switching} {1};
					#send !defend ${ses_name}mech
				};
				#kill delay support_switching;
				#kill delay support_switched;
				#variable {support[last_mode]} {$support[mode]};
				dismiss
			} {
				#nop checks while in support defend mode;
				#if {$mip[round] > 2 && $support_switching == 0 && "$jset[supportdefend]" == "on"} {
					#if {$support_defended == 0 && $mip[round] < 6} {
						#nop may have started the fight as assault so defend never fired;
						#send !support defend
					};#elseif {"$support[mode]" != "As" && $mip[round] > 6} {
						#nop support may not have needed to defend, due to double mob room or not tanking;
						#nop TODO: track - mech swapped to fire too early;
						#send !support assault $jset[supportfocus]
					}
				}
			}
		} {
			#nop support health is 0, resummon if possible and switch modes if sdef is on, or it was in defense mode when dismissed;
			#if {$clan > 0} {
				support summon;
				#if {"$jset[supportdefend]" == "on" || "$support[last_mode]" == "De"} {
					#delay {support_defend} {support defend} {2}
				}
			}
		}
	};

	#nop leave frenzy till the last minute to allow clan powers for support resets;
	#nop only frenzy outside of the initial few rounds to prevent support command lockouts;
	#if {$reset >= 99 && $mip[round] > 6 && $support_switching == 0} {
		#if {$clan > 0} {
			#send !frenzy
		}
	};

	#nop calling update_status here prevents #line gag working above;
	#nop update_status
}

#nop occurs right after a mode switch to defend, but may not fire if someone else is tanking
#action {^Vaid's Jugger Support Mech redirects}
{
	#nop entered defend mode but may not fire if we are not tanking;
	#if {$mip[round] == 0} {
		#nop when already in defend mode out of combat, no is delay necessary;
		#send !support assault $jset[supportfocus]
	} {
		#delay {support_switching} {#send !support assault $jset[supportfocus]} {2}
	};
	#variable {support_defended} {1}
}

#nop The computer chirps 'Your support moves into assault mode. Focusing: fire' 
#action {^The computer chirps 'Your support moves into assault mode}
{
	#nop may occur within the first four rounds;
	#delay {support_switched} {
		#nop flag the end of any switching activity;
		#variable {support_switching} {0}
	} {2}
}

#action {^Responding to %*'s call for support, a Jugger Support Mech enters the area, ready for combat.}
{
	cbrief ${ses_name}mech;
	#nop need a delay if switching a mode here;
}

#action {^Jugger setting supportdefend set to on.}
{
	#if {"$support[mode]" != "De"} {
		#send !support defend;
		#delay {2} {#send !cdefend clear}
	}
}

#action {^Jugger setting supportdefend set to off.}
{
	#if {"$support[mode]" != "As"} {
		#send !support asault $jset[supportfocus];
		#delay {2} {#send !cdefend ${ses_name}mech}
	}
}

#alias {on_watchdog_resume}
{
	#nop sometimes the killing blow doesn't register due to items such as runesword etc;
	#nop watchdog will call corpsetrig then this alias;
}

#alias {update_status}
{
	#var {my[hp][graph]}	{@graph{$my[hp][current];$my[hp][max]}};
	#var {my[sp][graph]}	{@graph{$my[sp][current];$my[sp][max]}};
	#var {my[gp1][graph]}	{@graph{$my[gp1][current];$my[gp1][max]}};
	#var {enemy[graph]}	{@graph{$enemy[hp];100}};
	#format {hp}		{%+5s} {@colscale{$my[hp][current];$my[hp][max]}};
	#format {hp_max}	{%-5s} {<128>$my[hp][max]<088>};
	#format {sp} 		{%+4s} {@colscale{$my[sp][current];$my[sp][max]}};
	#format {sp_max}	{%-4s} {<128>$my[sp][max]<088>};
	#format {gp1}		{   %+3s/%-3s} {@colscale{$my[gp1][current];100}} {@colscale{$my[gp1][truck];100}};
	#format {rounds}	{%+6s} {$mip[round]};

	#if {"$jset[coffinonly]" == "on"} {
		#format {corpsestatus} {<aff>%s<088>} {$corpses[coffin]}
	} {
		#format {corpsestatus} {<eea>%s<088>/<aff>%s<088>/%s<088>} {$corpses[inventory]} {$corpses[coffin]} {@onoffnumbercolour{$freezer;<ddf>;$corpses[truck]}}
	};
	#format {botstatus} {%+3s/%-3s} {$path_pos} {$path_len};
	#format {gstatus} {<088>%sP %sF%sC%sS%s%s%sH<088>} {@statuscolour{$pfocus}} {@statuscolour{$flipbirdkill}} {@statuscolour{$corpsetrig_on}} {@statuscolour{$scalers_enabled}} {@statuscolour{$combat_que_on}} {$area_rating} {@statuscolour{$global_hardmode}};
	
	#line ignore #showme {${scol}HP:$hp/$hp_max ${scol}SP:$sp/$sp_max  ${scol}ST:$gp1 ${scol}CR:<088>$rounds     ${scol}BS:<088>$botstatus ${scol}DA:@colscale{$dmg[cur][rnd];10000}} {-4};
	#line ignore #showme {${scol}HP:${my[hp][graph]}  ${scol}SP:${my[sp][graph]} ${scol}ST:${my[gp1][graph]} ${scol}EH:${enemy[graph]} ${scol}OK:<088>$onkill} {-3};

	#if {"$jset[gxpdelta]" == "on"} {
		#variable {gxpstatus} {@colscale{$gxp;100} +$gxpdelta ~$gxpaverage}
	} {
		#variable {gxpstatus} {@colscale{$gxp;100}}
	};

	#if {"$jset[supportbar]" == "off"} {
		#variable {shpshown} {@colscale{$support[hp];100;%}}
	} {
		#variable {shpshown} {@graph{$support[hp];100}}
	};

	#if {"$support[mode]" == "De"} {
		#format {supportstatus} {%s %+4s %sDe(%s) <088>%d/%d} {@sdefmodeansi{$jset[supportdefend]}} {$shpshown} {@modeansi{$support[mode]}} {$support[defend]} {$support[current]} {$support[max]}
	} {
		#format {supportstatus} {%s %+4s %sAs(%s) <088>%d/%d} {@sdefmodeansi{$jset[supportdefend]}} {$shpshown} {@modeansi{$support[mode]}} {$support[assault]} {$support[current]} {$support[max]}
	};

	#if {"$jset[hits]" == "on"} {
		#variable {hitsstatus} {${scol}Hits[@colscaleinv{$hits;60}${scol}] }
	} {
		#variable {hitsstatus} {}
	};

	#if {"$jset[heat]" == "on"} {
		#variable {heatstatus} {${scol}H[<088>@colscaleinv{$my[gp2][current];100}${scol}] }
	} {
		#variable {heatstatus} {}
	};

	#if {"$jset[nukes]" == "on"} {
		#variable {nukestatus} {${scol}N[<088>$nukes/$nukes_max${scol}] }
	} {
		#variable {nukestatus} {}
	};

	#if {"$jset[rod]" == "on"} {
		#format {rodstatus} {${scol}R[<088>%s${scol}] } {$rolm[charges]}
	} {
		#variable {rodstatus} {}
	};

	#if {"$jset[ammo]" == "on"} {
		#variable {ammostatus} {@colscale{$ammo[1];$jset[ammoamount]}};
		#if {"$ammo[2]"" != ""} {#variable {ammostatus} {$ammostatus/@colscale{$ammo[2];$jset[ammoamount]}}};
		#if {"$ammo[3]"" != ""} {#variable {ammostatus} {$ammostatus/@colscale{$ammo[3];$jset[ammoamount]}}};
		#if {"$ammo[4]"" != ""} {#variable {ammostatus} {$ammostatus/@colscale{$ammo[4];$jset[ammoamount]}}};
		#if {"$ammo[5]"" != ""} {#variable {ammostatus} {$ammostatus/@colscale{$ammo[5];$jset[ammoamount]}}};
		#variable {ammostatus} {${scol}A[${ammostatus}<088> $ammotypes[$jset[mounttype]][$jset[ammotype]_s]${scol}] }
	} {
		#variable {ammostatus} {}
	};

	#line ignore #showme {${ammostatus}${hitsstatus}${heatstatus}${scol}S[${supportstatus}${scol}] C[${corpsestatus}${scol}] S[${gstatus}${scol}] ${nukestatus}R[@colscale{$reset;100}${scol}] G[${gxpstatus}${scol}] ${rodstatus}} {-6}
}

#nop called from common.tin module when you log in
#alias {on_login}
{
	jump;w;home;mapgo home;
	dungeons;
	cq load;cq on;
	hp;gs
}

#nop called from common.tin module whenever you reconnect, and also the gswap module after a gswap
#alias {on_reconnect}
{
	#nop keep all these items to enable/disable scripts for them;
	keep coffin;keep cocoon;keep freeway;cuddle freeway;keep shield;
	cc;
	dungeons;
	touch diamond rune;
	cq load;cq on;
	hp;gs;
	pf;pf;
}

#alias {on_kshield_equip}
{
	#send !program bash;
	#send !exec l c;
	#gag {backward.$}
}

#alias {on_kshield_remove}
{
	#send !exec stop;
	#ungag {backward.$}
}

#nop handle lord stanley's cup hockey fan corpses
#alias {on_hockey_fan}
{
	#if {$my[gp1][current] >= 100} {
		#if {$my[gp1][truck] < 100} {
			#send !truck deener
		} {
			#send !fdeener	
		}
	} {
		#send !fdeener
	}
}

#nop called from the gswap module when you leave this gobj
#alias {on_gswap_leave}
{
	#nop add actions here;
}

#nop called from the gswap module when you enter this gobj
#alias {on_gswap_enter}
{
	reflex clear;
	repeat off;
	panic off;
	kt1;
	get all-weather backpack;
	get all-weather backpack;
	get all;
	wield rod;
	wield sword;
	wear shield;
	wear all;
	keep all;
	support summon;
	calltruck;
	hp;gs;
	ibrief all on
}

#alias {guildrun}
{
	.stop;
	#if {"$jset[winch]" == "on"} {touch winch rune} {go home};
	#delay {1} {
		go depot;donateall;
		go storage;donateall;
		go smithy;fix all;
		thisarea
	}
}

#alias {corpserun}
{
	.stop;
	#if {"$jset[winch]" == "on"} {touch winch rune} {go home};
	#delay {1} {
		go depot;donateall;
		go storage;donateall;
		go morgue;donate coffin;deslab all;wrap all;donate coffin;wrap all;donate coffin;
		home;bank;deposit all;withdraw $jset[coins];
		home;smithy;fix all;
		thisarea
	}
}

#alias {corpserun2}
{
	.stop;
	#if {"$jset[winch]" == "on"} {touch winch rune} {go home};
	#delay {1} {
		go depot;donateall;
		go home;nextshop;
		go morgue;donate coffin;deslab all;wrap all;donate coffin;wrap all;donate coffin;
		home;bank;deposit all;withdraw $jset[coins];
		home;smithy;fix all;
		thisarea
	}
}

#alias {startrun}
{
	.stop;
	go depot;donateall;
	go home;nextshop;
	go bank;deposit all;withdraw $jset[coins];
	home;smithy;fix all;
	examine dwarf
}

#nop use the dwaft in the smithy as a timing mechanism to let everything catch up before resuming/restarting
#action {^This rough looking dwarf looks at you cunningly with eyes of stone} {#delay {0.5} {.resume}}

#alias {on_rolm_changed}
{
	#if {"$support[mode]" != "De"} {
		#switch {"%1"} {
			#case "edged" {
				assault edged
			};
			#case "blunt" {
				assault blunt
			};
			#case "fire" {
				assault fire
			};
			#case "ice" {
				assault ice
			};
			#case "acid" {
				assault electric
			};
			#case "electric" {
				assault electric
			};
			#case "mind" {
				assault fire
			};
			#case "energy" {
				assault fire
			};
			#case "poison" {
				assault poison
			};
			#case "radiation" {
				assault radiation
			}
		}
	}
}

/* Disable jset[ammobuy] for energy mounts */
#action {^That gun is full already.}
{
	#variable {jset[ammobuy]} {off}
}

#action {^After your discount, it will cost %1 coins.}
{
	#if {"$jset[ammodonate]" == "on"} {
		#send !give %1 coins to eep;
		#send !truck vault
	}
}

/*
	creport
*/
#action {^  [%1%s] [%s%d] [{\s*}%d] $} {
	#format {cr_class} {%p} {%4};
	#format {cr_rnds} {%p} {%6};
	#if {$cr_rnds == 0} {
		#var {cr_hr} {Undefined}
	} {
		#math {cr_hr} {1.0*${cr_class}/${cr_rnds}*1800*.8};
		#format {cr_hr} {%d} {${cr_hr}};
		#format {cr_hr} {%g} {${cr_hr}}
	};
	#math {cr_class_tot} {${cr_class_tot} + ${cr_class}};
	#math {cr_rnds_tot} {${cr_rnds_tot} + ${cr_rnds}};
	#math {cr_count} {${cr_count} + 1};
	#format {cr_hr} {%+14s} {<078>${cr_hr}<088>};
	#var {cr_str} {[<078>%1%2<088>] [<078>%3%4<088>] [<138>%5%6<088>] [$cr_hr]};
	#line gag;
	#echo { $cr_str<088>}
}

#substitute {^ .--------------------------. .------------. .----.}
	    {<038> .-------------------------. .------------. .----. .--------------.<088>}
#substitute {^   Monster\'s Name                  Class      Rnds}
	    {    Monster's Name                Class      Rnds      Exp/Hour}

#action {^  Current Enemy: }
{
	#math	{cr_avg_class}	{1.0*${cr_class_tot}/${cr_count}};
	#format	{cr_avg_class}	{%d}	{${cr_avg_class}};
	#math	{cr_avg_rnds}	{1.0*${cr_rnds_tot}/${cr_count}};
	#format	{cr_avg_rnds}	{%d}	{${cr_avg_rnds}};
	#math 	{cr_avg_hr}	{1.0*${cr_class_tot}/${cr_rnds_tot}*1800*.8};
	#format	{cr_avg_hr}	{%d}	{${cr_avg_hr}};
	#format	{cr_avg_hr}	{%g}	{${cr_avg_hr}};
	#var	cr_class_tot	0;
	#var	cr_rnds_tot	0;
	#var	cr_count	0;
	#format	{cr_avg_class}	{%+32s}	{${cr_avg_class}};
	#format	{cr_avg_rnds}	{%+7s}	{${cr_avg_rnds}};
	#format	{cr_avg_hr}	{%+17s}	{${cr_avg_hr}};
	#format	{cr_avg_xp}	{%d}	{${cr_avg_xp}};
	#format	{cr_avg_xp}	{%+64s}	{${cr_avg_xp}};
	#var	{cr_str}	{  Average:${cr_avg_class}${cr_avg_rnds}${cr_avg_hr}};
	#showme {${cr_str}};
	#NOP #showme {${cr_avg_xp}}
}

/* Eval Enhancer */
#action {^[EDGE] [BLUN] [HEAT] [COLD] [ACID] [ELEC] [PSI ] [ENER] [TOXI] [RADI]} {
	#echo {<172> EVAL MATCH <088>};
	#variable {eval} {%0}
}

#alias {corpsetrig}
{
	#if {$combat_que_on} {
		#nop unlock any comabt que abilities that are once per fight;
		#nop TEMP - there's an issue with an 'any' que item and the mip[round] variable taking a round to reset;
		#variable {mip[round]} {0};
		cq refresh
	};

	#nop if using the support to tank, switch it to defend after every kill;
	#if {"$jset[support]" == "on" && "$jset[supportdefend]" == "on"} {
		#variable {support_defended} {0};
		#send !support defend
	};

	#if {$corpsetrig_on > 0} {
		#if {"$jset[ktrig]" == "off"} {
			#send !wrap;
			#if {"$freezer" == "on"} {#send !slab};
			#send !fdeener
		};
		#if {$corpsetrig_on == 1} {#send !get coins} {#send !divvy coins};
		#if {$backpack_module} {stacknext}
	};
	#else {
		#nop corpse trig off, send a divvy as it will unidle, and is semi useful;
		#send !divvy coins	
	};

	#if {$onkill_module} {onkillrun};
	#if {$cocoon} {#send !fuse}
}

#variable {ammotypes}
{
	{missile}
	{
		{fire} {6}
		{ice} {7}
		{poison} {8}
		{acid} {9}
		{radiation} {10}
		{1} {1}
		{2} {2}
		{3} {3}
		{4} {4}
		{5} {5}
		{6} {6}
		{6} {6}
		{7} {7}
		{8} {8}
		{9} {9}
		{10} {10}
		{1_s} {<118>Fi<088>}
		{2_s} {<048>Ic<088>}
		{3_s} {<028>Po<088>}
		{4_s} {<128>Ac<088>}
		{5_s} {<168>Ra<088>}
		{6_s} {<118>Fi<088>}
		{7_s} {<048>Ic<088>}
		{8_s} {<028>Po<088>}
		{9_s} {<128>Ac<088>}
		{10_s} {<168>Ra<088>}
	}
	{projectile}
	{
		{free} {1}
		{edged} {2}
		{blunt} {3}
		{fire} {4}
		{radiation} {5}
		{energy} {6}
		{gauss} {7}
		{1} {1}
		{2} {2}
		{3} {3}
		{4} {4}
		{5} {5}
		{6} {6}
		{6} {6}
		{7} {7}
		{1_s} {<068>Fr<088>}
		{2_s} {<068>Ed<088>}
		{3_s} {<178>Bl<088>}
		{4_s} {<118>Fi<088>}
		{5_s} {<168>Ra<088>}
		{6_s} {<158>En<088>}
		{7_s} {<068>Ga<088>}		
	}
}

#alias {mammo}
{
	#if {"%0" == ""} {
		#echo {<258>Usage: mammo <damage type/number> [d]<088>};
		#echo {<158> 1 <118>Srm Fire<088>};
		#echo {<158> 2 <048>Srm Ice<088>};
		#echo {<158> 3 <028>Srm Poison<088>};
		#echo {<158> 4 <128>Srm Acid<088>};
		#echo {<158> 5 <168>Srm Radiation<088>};
		#echo {<158> 6 <118>Lrm Fire<088>};
		#echo {<158> 7 <048>Lrm Ice<088>};
		#echo {<158> 8 <028>Lrm Poison<088>};
		#echo {<158> 9 <128>Lrm Acid<088>};
		#echo {<158>10 <168>Lrm Radiation<088>};
	} {
		#regexp {%0} {{((\d+)|fire|ice|poison|acid|radiation)(\sd)?}} {
			#if {"$ammotypes[missile][&2]" == ""} {
				#echo {<258>Invalid ammo type for missiles, try 1-10 or <118>fire<088>, <048>ice<088>, <028>poison<088>, <128>acid<088> or <168>radiation<088>.<088>}
			} {
				#nop change the mounttype in case a switch is needed;
				#variable {jset[mounttype]} {missile};

				#nop grab the ammotype mapping from the $ammotypes var and set the ammotype number;
				jset ammotype $ammotypes[missile][&2];

				#if {"&4" == " d"} {
					#nop change ammotype, dump ammo and repurcahse immediately;
					#send !dump 1;
					#send !truck ammo vbuy $jset[mounttype] $jset[ammotype] 1 $jset[ammoamount]
				} {
					#echo {<258>Ammo type will be changed during next reload.<088>};
				}
			}
		} {
			#echo {<258>Invalid ammo type for missiles, try 1-10 or <118>fire<088>, <048>ice<088>, <028>poison<088>, <128>acid<088> or <168>radiation<088>.<088>};
			#echo {<258>Make sure you only specify ammo that you have access to based on your mount and ammo techs.<088>}
		}
	}
}

#alias {pammo}
{
	#if {"%0" == ""} {
		#echo {<258>Usage: pammo <damage type/number> [d]<088>};
		#echo {<158> 1 <068>Machine gun ammo (free)<088>};
		#echo {<158> 2 <068>Autocannon ammo (edged)<088>};
		#echo {<158> 3 <078>AC LBX ammo (blunt)<088>};
		#echo {<158> 4 <118>AC high explosive ammo (fire)<088>};
		#echo {<158> 5 <168>AC uranium ammo (radiation)<088>};
		#echo {<158> 6 <158>Plasma ammo (energy)<088>};
		#echo {<158> 7 <068>Gauss ammo (edged)<088>};
	} {
		#regexp {%0} {{((\d+)|free|edged|blunt|fire|radiation|energy|gauss)(\sd)?}} {
			#if {"$ammotypes[projectile][&2]" == ""} {
				#echo {<258>Invalid ammo type for projectiles, try 1-7 or <068>free<088>, <068>edged<088>, <178>blunt<088>, <118>fire<088>,<168>radiation<088>, <158>energy<088> or <068>gauss.<088>}
			} {
				#nop change the mounttype in case a switch is needed;
				#variable {jset[mounttype]} {projectile};

				#nop grab the ammotype mapping from the $ammotypes var and set the ammotype number;
				jset ammotype $ammotypes[projectile][&2];

				#if {"&4" == " d"} {
					#nop change ammotype, dump ammo and repurcahse immediately;
					#send !dump 1;
					#send !truck ammo vbuy $jset[mounttype] $jset[ammotype] 1 $jset[ammoamount]
				} {
					#echo {<258>Ammo type will be changed during next reload.<088>};
				}
			}
		} {
			#echo {<258>Invalid ammo type for projectiles, try 1-7 or <068>free<088>, <068>edged<088>, <fff>blunt<088>, <118>fire<088>,<168>radiation<088>, <158>energy<088> or <068>gauss.<088>};
			#echo {<258>Make sure you only specify ammo that you have access to based on your mount and ammo techs.<088>}
		}
	}
}

#action {^The computer chirps 'Swap Complete!'}
{
	#delay {2} {empower}
}

#alias {assault}
{
	#if {"%1" == ""} {
		#send !support assault $jset[supportfocus]
	} {
		#send !support assault %1
	}	
}

#alias {defend}
{
	#send !support defend %1
}

#NOP Support defend toggle
#alias {sdef}
{
	#switch {"%1"} {
		#case {""} {
			#if {"$jset[supportdefend]" == "on"} {
				jset supportdefend off
			} {
				jset supportdefend on
			}
		};
		#case {"on"} {
			jset supportdefend on
		};
		#case {"off"} {
			jset supportdefend off
		};
		#default {
			#echo {<202> Invalid input!  Use: on or off <099>}
		}
	}
}

#function {modeansi}
{
	#if {"%1" == "De" || "%1" == "Defend"} {
		#variable result <afc>
	} {
		#variable result <fbb>
	}
}

#function {sdefmodeansi}
{
	#if {"%1" == "on"} {
		#variable result <afa>D<088>;
	} {
		#variable result ${scol}D<088>;
	}
}

#nop override the default colscale to receive a third argument
#function {colscale}
{
	#math per {100*%1/%2};
	#switch {1} {
		#case {$per >= 100}	{#return <168>%1%3<088>};
		#case {$per > 90}	{#return <afa>%1%3<088>};
		#case {$per > 80}	{#return <aea>%1%3<088>};
		#case {$per > 70}	{#return <bea>%1%3<088>};
		#case {$per > 60}	{#return <bda>%1%3<088>};
		#case {$per > 50}	{#return <cda>%1%3<088>};
		#case {$per > 40}	{#return <dca>%1%3<088>};
		#case {$per > 30}	{#return <dba>%1%3<088>};
		#case {$per > 20}	{#return <eba>%1%3<088>};
		#case {$per > 10}	{#return <eaa>%1%3<088>};
		#case {$per >= 0}	{#return <faa>%1%3<088>};
		#default 	{#return <088>%1%3}
	}
}

#nop colscale with reversed colours
#function {colscaleinv}
{
	#math per {100*%1/%2};
	#switch {1} {
		#case {$per <=  0}	{#return <168>%1%3<088>};
		#case {$per <= 10}	{#return <afa>%1%3<088>};
		#case {$per <= 20}	{#return <aea>%1%3<088>};
		#case {$per <= 30}	{#return <bea>%1%3<088>};
		#case {$per <= 40}	{#return <bda>%1%3<088>};
		#case {$per <= 50}	{#return <cda>%1%3<088>};
		#case {$per <= 60}	{#return <dca>%1%3<088>};
		#case {$per <= 70}	{#return <dba>%1%3<088>};
		#case {$per <= 80}	{#return <eba>%1%3<088>};
		#case {$per <= 90}	{#return <eaa>%1%3<088>};
		#case {$per <= 100}	{#return <faa>%1%3<088>};
		#default 	{#return <088>%1%3}
	}
}


#nop override from mip.tin
#alias {.mipProcessGlineJuggernaut}
{
	#if {%1 == 1} {
		#regexp {$mip[gline][1]} {{Ammo:\[(\d+)?/?(\d+)?/?(\d+)?/?(\d+)?/?(\d+)?\]} <838>Gxp: %d.%d\%<099> Hits: \[%d\] <868>Coffin: %d/%d} {
			#VAR {ammo[1]}				{&2};
			#VAR {ammo[2]}				{&3};
			#VAR {ammo[3]}				{&4};
			#VAR {ammo[4]}				{&5};
			#VAR {ammo[5]}				{&6};
			#VAR {gxp}					{&7.&8};
			#VAR {hits}					{&9};
			#VAR {corpses[coffin]}		{&10};
			#VAR {corpses[coffinsize]}	{&11}
		}
	}; #elseif {%1 == 2} {
		#regexp {$mip[gline][2]} {Nukes: [%d/%d]<099> <858>Support: [%d/%d]<099> Reset: [%d\%] Suit: %w} {
			#VAR {nukes}			{&1};
			#VAR {nukes_max}		{&2};
			#VAR {support[current]}	{&3};
			#VAR {support[max]}		{&4};
			#VAR {reset}			{&5};
			#VAR {suit}				{&6}
		}
	}; #else {
		#echo {<171> Invalid Gline Number <088>}
	}
} {1}


/*
	jset - jugger settings that save through logins.
	Type 'jset info'
*/
#variable {jsetinfo}
{
	{numbers}		{{group}{miscellaneous}	{default}{off}			{format}{^(on|off)$}				{help} {Set to on/off based on the presence of the numbers VAF}}
	{winch}			{{group}{miscellaneous}	{default}{off}			{format}{^(on|off)$}				{help} {Use the rolm for guildruns instead of running}}
	{ktrig}			{{group}{miscellaneous}	{default}{off}			{format}{^(on|off)$}				{help} {Handle corpses using ktrig vaf instead of from corpsetrig}}
	{trans}			{{group}{miscellaneous}	{default}{off} 			{format}{^(on|off)$}				{help} {Access to the transpose power at 60}}
	{transpc}		{{group}{miscellaneous}	{default}{95}			{format}{^([1-9][0-9]{0,1})$}		{help} {Stim percentage to start transposing}}
	{coins}			{{group}{miscellaneous}	{default}{10000}		{format}{^([1-9][0-9]{0,6})$}		{help} {Number of coins to carry around after a guildrun}}
	{rod}			{{group}{miscellaneous}	{default}{off}			{format}{^(on|off)$}				{help} {Use Rod of Lordly might to heal SP}}
	{truckname}		{{group}{miscellaneous}	{default}{}				{format}{^([a-z]{1,20})$}			{help} {Your truck's name (lowercase)}}
	{nukedonate}	{{group}{miscellaneous}	{default}{on}			{format}{^(on|off)$}				{help} {Automatically fire your nukes at someone's locked target}}
	
	{support}		{{group}{support}		{default}{off}			{format}{^(on|off)$}				{help} {Support mech automation on/off}}
	{supportdefend}	{{group}{support}		{default}{off}			{format}{^(on|off)$}				{help} {Support mech defends you on/off}}
	{supportbar}	{{group}{support}		{default}{off}			{format}{^(on|off)$}				{help} {Support show a health bar intead of percentage}}
	{supportbrief}	{{group}{support}		{default}{off}			{format}{^(on|off)$}				{help} {Brief your support mech's damage output}}
	{supportfocus}	{{group}{support}		{default}{fire}			{format}{^(on|off)$}				{help} {Default dmg type to use for your support}}
	{supportminhp}	{{group}{support}		{default}{20}			{format}{^([1-9][0-9]{0,2})$}		{help} {Min health of support before rebuilding it}}
	{supportkdelay}	{{group}{support}		{default}{off}			{format}{^(on|off)$}				{help} {Delay before attacking with defensive support}}
	
	{ammoamount}	{{group}{ammo}			{default}{500}			{format}{^([1-9][0-9]{0,6})$} 		{help} {Ammount to purchase for truck supply runs}}
	{ammomin}		{{group}{ammo}			{default}{60}			{format}{^([1-9][0-9]{0,6})$} 		{help} {Minimum ammo level before starting a truck supply run}}
	{ammobuy}		{{group}{ammo}			{default}{off}			{format}{^(on|off)$}				{help} {Toggle ammo supply runs on/off}}
	{ammotype}		{{group}{ammo}			{default}{1} 			{format}{^([1-9][0]{0,1})$}			{help} {Type of ammo to purchase for ammo supply runs}}
	{ammodonate}	{{group}{ammo}			{default}{off}			{format}{^(on|off)$}				{help} {Donate the ammo cost back to the vault}}
	{mounttype} 	{{group}{ammo}			{default}{projectile}	{format}{^(projectile|missile)$}	{help} {Type of weapon used for ammo supply runs (projectile/missile)}}

	{ammo}			{{group}{display}		{default}{on}			{format}{^(on|off)$}				{help} {Show ammo on the guild bar}}
	{gxpdelta}		{{group}{display}		{default}{on}			{format}{^(on|off)$}				{help} {Toggle display of gxp delta per round}}
	{hpbar}			{{group}{display}		{default}{on}			{format}{^(on|off)$}				{help} {Your default HP bar gag state}}
	{hits}			{{group}{display}		{default}{off}			{format}{^(on|off)$}				{help} {Show incoming hit count on the guild bar}}
	{heat}			{{group}{display}		{default}{off}			{format}{^(on|off)$}				{help} {Show heat on the guild bar}}
	{nukes}			{{group}{display}		{default}{on}			{format}{^(on|off)$}				{help} {Show nukes on the guild bar}}
	{brief}			{{group}{display}		{default}{off}			{format}{^(on|off)$}				{help} {Brief your combat messages (requires numbers VAF)}}
	{showenhance}	{{group}{display}		{default}{on}			{format}{^(on|off)$}				{help} {Toggle display of your enhance (heal) message}}
	{showcrits}		{{group}{display}		{default}{on}			{format}{^(on|off)$}				{help} {Toggle display of your critical hit message}}
	{coffinonly}	{{group}{display}		{default}{on}			{format}{^(on|off)$}				{help} {Toggle display of non-coffin corpse sources}}

	{critcolour}	{{group}{colours}		{default}{fff}		{format}{^([a-fA-F0-9]{3})$}			{help} {Mount critical hit colour}}
	{mountcolour}	{{group}{colours}		{default}{ffa}		{format}{^([a-fA-F0-9]{3})$}			{help} {Mount damage message colour}}
	{mountfcolour}	{{group}{colours}		{default}{fda}		{format}{^([a-fA-F0-9]{3})$}			{help} {Mount lock failure message colour}}
	{tankcolour}	{{group}{colours}		{default}{fba}		{format}{^([a-fA-F0-9]{3})$}			{help} {Tank damage message colour}}
	{mechcolour}	{{group}{colours}		{default}{268}		{format}{^([a-fA-F0-9]{3})$}			{help} {Tank damage message colour}}
	{physcolour}	{{group}{colours}		{default}{168}		{format}{^([a-fA-F0-9]{3})$}			{help} {Your punch/kick/dfa damage message colour}}
	{pdcolour}		{{group}{colours}		{default}{118}		{format}{^([a-fA-F0-9]{3})$}			{help} {Point defense colour}}
	{theme}			{{group}{colours}		{default}{default}	{format}{^([a-zA-Z0-9\s]{1,30})$}		{help} {Theme name applied to tables, messages etc}}
}

#alias {_jset_reset}
{
	#echo {<258>Juggernaut settings have been reset to default.<088>};
	#class {juggersettings} {kill};
	#class {juggersettings} {open};
	#variable {jset} { };
	#class {juggersettings} {close};
	#class {juggersettings} {save};
	#foreach {*jsetinfo[%*]} {name} {#variable {jset[$name]} {$jsetinfo[$name][default]}};
	#class {juggersettings} {write} {.tt/char/$ses_name-jset.tin}
}

#alias {_jset_load}
{
	#class {juggersettings} {kill};
	#class {juggersettings} {read} {.tt/char/$ses_name-jset.tin};
	#class {juggersettings} {size} {jsetsize};
	#if {$jsetsize == 0} {
		#echo {<258>Juggernaut settings file not found!<088>};
		_jset_reset;
		#unvariable {jsetsize}
	};

	#list {jsetgroups} {create} {ammo;support;display;miscellaneous;colours}
}

#alias {jset}
{
	#if {"%1" == ""} {
		#draw $jthemes[$jset[theme]][lines] scroll line 1 1 1 80;
		#echo {$jthemes[$jset[theme]][headings]Setting              Value<088>};
		#draw $jthemes[$jset[theme]][lines] scroll line 1 1 1 80;

		#foreach {$jsetgroups[%*]} {group} {     
			#echo {$jthemes[$jset[theme]][subheadings]%n<088>} {$group};
			#foreach {*jsetinfo[%*]} {name} {
				#if {"$group" == "$jsetinfo[$name][group]"} {
					#if {"$group" == "colours"} {
						#echo {     %-15s<088> <%s>%.60s<088>} {$name} {$jset[$name]} {$jset[$name]}
					} {
						#echo {     %-15s<088> %.60s} {$name} {$jset[$name]}
					}
				}
			}
		};
		#draw $jthemes[$jset[theme]][lines] scroll line 1 1 1 80
	};
	#elseif {"%1" == "reset"} {
		#if {$jset_reset_count == 0} {
			#echo {<258>Are you sure you wish to reset your jugger settings?\nType <158>jset reset<258> again within 10 seconds to confirm.<088>};
			#variable {jset_reset_count} {1};
			#delay {jset_reset} {
				#variable {jset_reset_count} {0};
				#echo {<258>Jugger settings reset period has timed out.<088>}
			} {10}
		} {
			#variable {jset_reset_count} {0};
			_jset_reset
		}				
	};
	#elseif {"%1" == "help"} {
		#draw $jthemes[$jset[theme]][lines] scroll line 1 1 1 80;
		#echo {$jthemes[$jset[theme]][headings]Setting              Help<088>} {$jsetout};
		#draw $jthemes[$jset[theme]][lines] scroll line 1 1 1 80;

		#foreach {$jsetgroups[%*]} {group} {     
			#echo {$jthemes[$jset[theme]][subheadings]%n<088>} {$group};

			#foreach {*jsetinfo[%*]} {name} {
				#if {"$group" == "$jsetinfo[$name][group]"} {
					#echo {     %-15s<088> %.60s} {$name} {$jsetinfo[$name][help]}
				}
			}
		};
		#draw $jthemes[$jset[theme]][lines] scroll line 1 1 1 80
	};
	#else {
		#regexp {%0} {{([a-z]+) ([a-zA-Z0-9\._\'\s\-]+)}} {
			#if {"$jsetinfo[&2][format]" != ""} {
				#regexp {&3} {{$jsetinfo[&2][format]}} {
					#if {"&3" == "clear"} {
						#nop for freeform text entries, they can be cleared with the clear argument;
						#variable {jset[&2]} {};
						#echo {<258>Jugger setting <158>&2<258> has been <158>cleared<258>.<088>}
					} {
						#variable {jset[&2]} {&3};
						#showme {<258>Jugger setting <158>&2<258> set to <158>&3<258>.<088>}
					};
					_jset_save
				} {
					#echo {<258>Invalid jset value <158>&3<258> for <158>&2<258>.<088>}
				}
			} {
				#echo {<158>&2<258> is not a valid jset option.<088>}
			}
		} {
			#echo {<258>Syntax is <158>jset <option> <value><258>.<088>}
		}
	}
}

#nop used internally for resetting boot-long settings 
#alias {_jset_clear}
{
	#nop #variable {jset[hidden]} {};
	_jset_save
}

#alias {_jset_save}
{
	#class {juggersettings} {write} {.tt/char/$ses_name-jset.tin}
}

/*
	INIT
*/
_jset_load
jdmg reset

#class {juggernaut} {close}
