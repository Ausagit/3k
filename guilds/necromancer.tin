#nop necromancer.tin
/*
REQUIRED MODULES
	You need to include the common.tin module in your character file.
		#read {.tt/3k/modules/common.tin}
	Modules required (included from the common module above):
		backpack.tin (uses by default 4 gentech backpacks)
		combat_que.tin
		mask.tin
		scalers.tin
		watchdog.tin
		onkill.tin
	You can use your own, or use the smithy.tin bot file

GUILD SETUP
	Using cconfigure, configure gline1 and gline2 as below, it doesn't matter if you add extras or less to gline1,
	however gline2 requires all the reagents for the stockall alias to work correctly.
	gline1: worth, powers, protection, repower, circle, fused, follower
	gline2: add all reagents
	
	HP Bar config, add the elements below to your bar, make sure Hit Points is first, and the others listed always remain on the first line of your hp bar.
	If you add more and it wraps, add a new action for it down below in this file.
		1 [Hit Points]
  		2 [Necro Points/Corpses]
  		3 [Undead Follower/Coffin]
		4 [Memory] (drm)    Note: add alter if you are a werebeast, shapeshift if a vampire, or dream if you are a reaper/pure/lich. Only add one of the three types.

COMMANDS
	nset			- configure various necromatic settings, 'nset help' for more details
	cre/crd			- enable/disable automatic corpse runs (dropoffs to Duncan)
	gre/grd			- enable/disable automatic guild runs (low dreams)
	cte/ctd/ctp 	- corpse trigger, enable/disable/enable party
	studyrun [arg]	- run to the guild to study, execute arg when done
	storeall		- use manually or automatically in guildruns to store all your corpses at duncan, excluding coffin by default
	cud				- create an undead follower using the configured name and description from nset
*/

#nop required include for common functionality and modules
#read {.tt/3k/modules/necropowers.tin}

#nop this file has my personal stuff in it, you can just ignore the failed read or make your own
#read {.tt/3k/guilds/necromancer_custom.tin}

#class {necromancer} {kill}
#class {necrosettings} {kill}
#class {necromancer} {open}

#class {necrosettings} {read} {.tt/char/$ses_name-nset.tin}
#class {necrosettings} {size} {nsetsize};

#if {$nsetsize == 0} {
	#echo {Necro settings file not found, creating default.};
	#class {necrosettings} {kill};
	#class {necrosettings} {open};
	#variable {nset[study_on]} {1};
	#variable {nset[winch_on]} {1};
	#variable {nset[coffin_max]} {5};
	#variable {nset[form]} {lich};
	#variable {nset[ktrig_on]} {0};
	#variable {nset[invoke]} {power};
	#variable {nset[follower_name]} {};
	#variable {nset[follower_gender]} {};
	#variable {nset[follower_desc]} {};
	#variable {nset[follower_enter]} {};
	#variable {nset[follower_exit]} {};
	#variable {nset[follower_max]} {10};
	#variable {nset[heals_low]} {0};
	#variable {nset[stash_note1]} {};
	#variable {nset[stash_note2]} {};
	#variable {nset[inventory_max]} {5};
	#variable {nset[coins]} {10000};
	#class {necrosettings} {close};
	#class {necrosettings} {save};
	#class {necrosettings} {write} {.tt/char/$ses_name-nset.tin};
	#unvariable {nsetsize}
}

#variable {guild} {necromancer}
#variable {my[undead]} {0}
#variable {path_len} {0}
#variable {path_pos} {0}
#variable {halting} {0}
#variable {guildruns_on} {1}
#variable {corpseruns_on} {0}
#variable {scol} {<bbb>}
#variable {laststatusbar} {}
#variable {ringdark_on} {0}
#variable {ktrig} {wrap/preserve get}
#variable {low_coins} {0}

#highlight {^You prepare the corpse with magical energies and store it away.} {yellow}
#highlight {^You prepare the corpse with your innate, necromantic energies.} {yellow}
#highlight {^The corpse is already preserved, but grabbing it anyway.} {yellow}
#highlight {^You chant softly, casting your own soul over the fallen.} {light yellow}

#ungag {^HP[}
#gag {^The spirit touches the corpse and you watch it crystalize.  With the briefest}
#gag {^nudge, the frozen corpse shatters, releasing the magical energy to be joined}
#gag {^with your own.$}
#gag {^The aegis rune on the PsiMace pulses for a moment.}
#gag {^From afar, Death favors you.}
#gag {^Death tells you:}
#gag {^  I can feel you moving closer}
#gag {^  I can wait for you}
#gag {^  We will be together soon enough}
#gag {^  You escaped my grasp this time}
#gag {^  Live onward my}
#gag {^  Don't worry my %1, I always collect my debts}
#gag {^  %1, my %2, I will embrace you soon}
#gag {^  Your destiny will wait a bit longer}

#substitute {C:O=|======> } {}
#substitute {C:D=##====<E } {}
#substitute {^  My favor will cost you} {<218>Death tells you: <138>My favor will cost you}

#alias {nset}
{
	#if {"%1" == ""} {
		#local {nsetout} {};
		#format {nsetout} {<258>------------------------------------------------------------------------------<088>} {$nsetout};
		#format {nsetout} {%s\n<158> Setting             Value<088>} {$nsetout};
		#format {nsetout} {%s\n<258>------------------------------------------------------------------------------<088>} {$nsetout};
		#foreach {*nset[%*]} {name} {
			#format {nsetout} {%s\n <258>%-20s<088> %.55s} {$nsetout} {$name} {$nset[$name]}
		};
		#echo {$nsetout}
	};
	#elseif {"%1" == "help"} {
		#local {nsetout} {};
		#format {nsetout} {<258>------------------------------------------------------------------------------<088>} {$nsetout};
		#format {nsetout} {%s\n<158> Setting              Description<088>} {$nsetout};
		#format {nsetout} {%s\n<258>------------------------------------------------------------------------------<088>} {$nsetout};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {coffin_max}		{Your coffin's maximum corpse capacity};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {coins}			{Number of coins to carry around after a guildrun};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {heals_low}		{If guildruns on, study when form heal < this. 0 = disable};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_desc}	{Your follower's description for use with the cud alias};		
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_enter}	{Your follower's enter message for use with the cud alias};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_exit}	{Your follower's exit message for use with the cud alias};		
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_gender}{Your follower's gender for use with the cud alias};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_max}	{Your follower's maximum corpse capacity};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_name}	{Your follower's name for use with the cud alias};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {form}			{Your necromatic form, for paths and setting configs};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {inventory_max}	{Your carried maximum corpse capacity};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {invoke}			{Set to your default/preferred invoke dmg type};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {ktrig_on}		{Handle corpses using the ktrig vaf instead of qtrance};		
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {stash_note1}	{Roomnote for your 1st corpse stash for auto restocking};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {stash_note2}	{Roomnote for your 2nd corpse stash for auto restocking};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {study_on}		{Set to 0 if you are Tier III or above};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {winch_on}		{Use the rolm for guildruns instead of running};
		#echo {$nsetout}
	};
	#else {
		#regexp {%0} {{(winch_on|ktrig_on|study_on|invoke|follower_name|follower_gender|follower_desc|follower_enter|follower_exit|follower_max|coffin_max|inventory_max|form|heals_low|stash_note1|stash_note2|coins) (.+)}} {
			#nop add input checking later;
			#variable {nset[&2]} {&3};
			#class {necrosettings} {write} {.tt/char/$ses_name-nset.tin};
			#echo {<258>Necromatic setting <158>&2<258> set to <158>&3<258>.}
		} {
			#echo {<258>Syntax is nset <winch_on|ktrig_on|study_on|invoke|follower_name|follower_gender|follower_desc|follower_enter|follower_exit|follower_max|coffin_max|inventory_max|form|heals_low|stash_note1|stash_note2|coins> <value>.<088>}
		}
	}
}

#nop called from common.tin module when you log in
#alias {on_guild_login}
{
	startwatchdog;
	jump;w;home;mapgo home;
	dungeons;
	cq_setup;
	cip;hp;gs;
	#delay {4} {ktrigsetup}
}

#nop called from common.tin module whenever you reconnect
#alias {on_guild_reconnect}
{
	startwatchdog;
	keep coffin;keep morgue;keep cooler;keep mask;
	cc;
	dungeons;
	touch diamond rune;
	cq_setup;
	hp;gs;
	#delay {4} {ktrigsetup}
}

#nop setup combat que
#alias {cq_setup}
{
	#if {$combat_que_module} {
		cq clear;
		cq add ewell/8/start/990/0/(energy well;
		cq add raven/9/start/0/0/touch raven rune;
		cq add owl/8/end/0/0/touch owl rune;
		cq add bloodarc/8/start/500/0/barc;
		cq add familiar/0/start/0/0/call;
		cq add prime/6/start/501/0/prime;
		cq add unholyground/7/med/0/0/unholy ground;
		cq add illume/1/any/0/1/illume/$:my[gp1][perc] < 80 && $:my[glamors][current] > 0;
		cq add heal/1/any/0/1/(heal $:ses_name/$:my[hp][current] < 1000;
		cq add rings/0/start/300/0/ringdark;
		cq disable rings;
		cq on
	} {
		#echo {Unable to setup combat que - module not loaded}
	}
}

#alias {a} {#send !absorb}
#alias {aa} {#send !absorb prime}
#alias {p} {#send !preserve}
#alias {pg} {#send !preserve get}
#alias {ug} {#send !unholy ground}
#alias {sb} {#send !soulbind}
#alias {barc} {#send !bloodarc $mobname}

#alias {npr} {#send !nocturnum prime}
#alias {dpr} {#send !diurnum prime}
#alias {da} {#send !detect alignment}
#alias {ng} {#send !necrogram}
#alias {com} {#send !chat}
#alias {comm} {#send !chat}
#alias {tp} {#send !teleport}
#alias {tp1} {#send !teleport 1}
#alias {tp2} {#send !teleport 2}
#alias {tp3} {#send !teleport 3}
#alias {tp4} {#send !teleport 4}
#alias {tp5} {#send !teleport 5}
#alias {ts1} {#send !teleport set 1}
#alias {ts2} {#send !teleport set 2}
#alias {ts3} {#send !teleport set 3}
#alias {ts4} {#send !teleport set 4}
#alias {ts5} {#send !teleport set 5}
#alias {ka} {#send !kill a}
#alias {kb} {#send !kill b}
#alias {kc} {#send !kill c}
#alias {kd} {#send !kill d}
#alias {ke} {#send !kill e}
#alias {kf} {#send !kill f}
#alias {kg} {#send !kill g}
#alias {kh} {#send !kill h}
#alias {ki} {#send !kill i}
#alias {kj} {#send !kill j}
#alias {kk} {#send !kill k}
#alias {kl} {#send !kill l}
#alias {km} {#send !kill m}
#alias {kn} {#send !kill n}
#alias {ko} {#send !kill o}
#alias {kp} {#send !kill p}
#alias {kq} {#send !kill q}
#alias {kr} {#send !kill r}
#alias {ks} {#send !kill s}
#alias {kt} {#send !kill t}
#alias {ku} {#send !kill u}
#alias {kv} {#send !kill v}
#alias {kw} {#send !kill w}
#alias {kx} {#send !kill x}
#alias {ky} {#send !kill y}
#alias {kz} {#send !kill z}

#alias {cip} {#send !comtrance invoke power}
#alias {cie} {#send !comtrance invoke edged}
#alias {cic} {#send !comtrance invoke crushing}
#alias {cim} {#send !comtrance invoke psionic}

#alias {gre} {#variable {guildruns_on} {1};#echo {Guildruns enabled.}}
#alias {grd} {#variable {guildruns_on} {0};#echo {Guildruns disabled.}}
#alias {cre} {#variable {corpseruns_on} {1};#echo {Corpse run drop-offs enabled.}}
#alias {crp} {#variable {corpseruns_on} {2};#echo {Corpse run pick-ups enabled.}}
#alias {crd} {#variable {corpseruns_on} {0};#echo {Corpse runs disabled.}}

#alias {donateall} {donate all;#if {$backpack_module} {donatebpall}}
#alias {sellall} {sell all;#if {$backpack_module} {sellbpall}}

#alias {cud}
{
	#send !unwrap;animate dead;chant;study tome;=lead;
	#if {"$nset[follower_name]" != ""}   {=name $nset[follower_name]};
	#if {"$nset[follower_gender]" != ""} {=gender $nset[follower_gender]};
	#if {"$nset[follower_desc]" != ""}   {=describe $nset[follower_desc]};
	#if {"$nset[follower_enter]" != ""}  {=setmin $nset[follower_enter]};
	#if {"$nset[follower_exit]" != ""}   {=setmout $nset[follower_exit]}
}

#alias {ktrigsetup}
{
	#local {new_ktrig} {};

	#if {$corpses[coffin] < $nset[coffin_max]} {
		#nop coffin has space;
		#local {new_ktrig} {keep all corpse/wrap}
	} {
		#nop coffin is full;
		#if {"$freezer" == "on" && $corpses[freezer] < 50} {
			#nop freezer has space, keep wrapping though to get the biggest corpses in the coffin;
			#local {new_ktrig} {keep all corpse/wrap/slab}
		} {
			#nop freezer is full;
			#if {"$cooler" == "on" && $corpses[cooler] < 50} {
				#nop cooler has space;
				#local {new_ktrig} {keep all corpse/preserve get/cooler corpse}
			} {
				#nop cooler is full or not enabled;
				#if {$my[undead] > 0 && $corpses[follower] < 24} {
					#nop undead has space;
					#local {new_ktrig} {preserve/=get corpse}
				} {
					#nop undead is full (or not summoned);
					#local {new_ktrig} {preserve get}
				}
			}
		}
	};

	#if {$ringdark_on} {
		#local {new_ktrig} {remove ring of darkness/wear ring of light/$new_ktrig}
	};

	#if {"$new_ktrig" != "$ktrig"} {
		#variable {ktrig} {$new_ktrig};
		#if {$nset[ktrig_on]} {
			#send !ktrig $ktrig
		}
	}
}

#alias {ringson}
{
	#variable {ringdark_on} {1};
	cq enable rings;
	#gag {^You are infused with the spirit as you don the item.};
	#gag {^The spirit fades from your grasp as you remove the item.};
	#gag {^The moment you remove the ring, the cloak of darkness surrounding};
	#gag {you disperses.  In but a few seconds, no evidence exists of its};
	#gag {presence.$};
	#gag {^The Ring sparkles into color, eventually stabilizing into a faint white};
	#gag {light which permits you to see far ahead.};
	#gag {^The light from the ring disappears the instant it is removed from};
	#gag {your finger.$};
	#gag {^As you don the ring, the air about you coalesces into a deep, soft};
	#gag {blackness.  The darkness swirls about your being until light seems};
	#gag {but a distant memory.$};
	ringlight;
	#delay {0.5} {ktrigsetup}
}
#alias {ringsoff}
{
	#variable {ringdark_on} {0};
	cq disable rings;
	#ungag {^You are infused with the spirit as you don the item.};
	#ungag {^The spirit fades from your grasp as you remove the item.};
	#ungag {^The moment you remove the ring, the cloak of darkness surrounding};
	#ungag {you disperses.  In but a few seconds, no evidence exists of its};
	#ungag {presence.$};
	#ungag {^The Ring sparkles into color, eventually stabilizing into a faint white};
	#ungag {light which permits you to see far ahead.};
	#ungag {^The light from the ring disappears the instant it is removed from};
	#ungag {your finger.$};
	#ungag {^As you don the ring, the air about you coalesces into a deep, soft};
	#ungag {blackness.  The darkness swirls about your being until light seems};
	#ungag {but a distant memory.$};
	ringlight;
	#delay {0.5} {ktrigsetup}
}
#alias {ringlight} {remove ring of darkness;wear ring of light}
#alias {ringdark} {remove ring of light;wear ring of darkness}

#alias {suitup}
{
	jump;e;home;morgue;acquire coffin;home;bank;deposit all;withdraw $nset[coins];home;
	chaos;enter;s;s;w;w;enter;n;n;n;n;#2 buy moon rocks;s;s;s;s;leave;e;e;n;n;vortex;home;
	mapgo home
}

#alias {on_watchdog_resume}
{
	#if {$ringdark_on} {ringlight}
}

#alias {on_hockey_fan}
{
	#if {$ringdark_on} {
		#local {go_dark} {1};
		ringlight;
	};
	#if {$my[gp1][perc] > 95 && $my[hp][perc] < 100}
	{
		#send !qtrance preserve/absorb prime
	} {
		#send !qtrance preserve/absorb
	};
	#if {$go_dark} {
		ringdark;
	}
}

#alias {guildsetup}
{
	.stop;
	dungeons;
	#if {$combat_que_module} {
		rate run
	};
	#if {$scalers_module} {
		scaler run
	};

	#nop triger .resume from examining the satchel to allow things to catch up;
	#delay {2} {#send !examine crafter's satchel}
}

#action {^This leather satchel was issued to you}
{
	#if {$bot == 1} {
		#if {$bot_debug} {
			update_chat Starting $bots[stepper]: Dreams[$my[powers][dream]] Corpses[$corpsestatus]
		};
		#delay {1} {.resume}
	}
}

#alias {storeall}
{
	=summon;
	examine duncan
}
#action {^Duncan is the keeper over the ancient necromantic crypts}
{
	deslab all;
	#if {"%1" != ""} {unwrap all};
	#if {$corpses[follower] > 0} {
		=drop all;
	};
	#if {"$cooler" == "on"} {
		#$corpses[cooler] uncooler corpse
	};
	#if {$mask_module == 1 && "$mask_glyph_state" != "unknown"}
	{
		mask all;
		#if {"$mask_glyph_state" == "off"} {trace glyph};
		#delay {4} {
			#variable {autostoreall} {1};
			mask on;
			get all;store all
		}
	} {
		#variable {autostoreall} {1};
		get all;store all
	}
}
#action {^Duncan says: Thank you for donating}
{
	#if {$autostoreall} {
		get all;store all
	}
}
#action {^Duncan says: But you don't have any corpses}
{
	#if {$autostoreall} {
		#variable {autostoreall} {0};
		e;u;u;w;w;w;stockall;
		e;e;e;d;#5 e;
		#nop at rr;
		#if {$nset[study_on]} {
			form_study
		} {
			end_run
		}
	}
}
#action {^Duncan says: The guild is extremely pleased!}
{
	#if {$autostoreall} {
		get all;store all
	}
}


#action {^  You do not have %1 gold coins to contribute master.}
{
	#variable {low_coins} {1};
}

#action {^You hand %1 coins to %2, who then %3 to the guild.}
{
	#variable {low_coins} {0};
}

#alias {startrun}
{
	#nop restock run betwen steppers using smithy.tin - resume safe;
	#variable {resume_action} {.resume};
    .stop;
	#delay {0.5} {
		home;bank;deposit all;withdraw $nset[coins];home;
		fantasy;portal;#15 e;leave;#4 e;#2 ne;n;#2 ne;e;#2 sw;portal;#8 n;
		#6 w;donateall;
		#if {$corpseruns_on == 1} {
			e;d;w;storeall
		} {
			e;u;w;w;w;stockall;
			e;e;e;d;#5 e;
			#nop at rr;
			#if {$nset[study_on]} {
				form_study
			} {
				end_run
			}
		}
	}
}

#alias {end_run}
{
	#nop starting at receiving room;
	#8 s;portal;ne;ne;e;e;portal;home;smithy;
	mapgo smithy;
	fix all;
	hp;
	#delay {2} {examine dwarf}
}

#action {^This rough looking dwarf looks at you cunningly with eyes of stone}
{
	#nop use the dwaft in the smithy as a timing mechanism to let everything catch up before resuming/restarting;
    #if {"$resume_action" != ""} {
        #echo {Resuming via '$resume_action'.};
        #delay {0.5} {$resume_action}
    }
}

#alias {guildrun}
{
	#nop restock and corpse/item donate;
	#nop restart the stepper rather than resume to avoid piling up monsters or hitting blockers;
	#if {"%1" == ""} {
		#variable {resume_action} {thisarea}
	} {
		#variable {resume_action} {%1}
	};
    .stop;
	killbot;
	#if {$nset[winch_on]} {touch winch rune} {go home};
	#delay {0.5} {
		#if {$corpseruns_on == 2} {
			#nop corpse_unstash;
		};
		#delay {4} {
			bank;deposit all;withdraw $nset[coins];home;
			fantasy;portal;#15 e;leave;#4 e;#2 ne;n;#2 ne;e;#2 sw;portal;#8 n;
			#6 w;donateall;
			#if {$corpseruns_on == 1} {
				e;d;w;storeall
			} {
				e;u;w;w;w;stockall;
				e;e;e;d;#5 e;
				#nop @rr;
				#if {$nset[study_on]} {
					form_study
				} {
					end_run
				}
			}
		}
	}
}

#nop work in progress
#alias {corpse_unstash}
{
	#nop brute force restock (for now);
	#if {"$nset[stash_note1]" != ""} {
		go $nset[stash_note1];
		keep all;
		#if {"$freezer" == "on"} {
			#nop move fresh corpses to the freezer;
			unwrap all;slab all;wrap all;
		};
		unkeep all corpse;
		#$corpses[inventory] drop corpse;
		#delay {2} {
			#50 get corpse from box;
			#50 drop corpse;
			=get all;
			wrap all;
			#25 get corpse from box;
			#25 drop corpse;
			#$nset[inventory_max] get corpse;
			keep all corpse;
			gg;put all in box;
			gg;put all in box;
			go home
		}
	}
}

#nop work in progress
#alias {corpse_stash}
{
	deslab all;
	mask active;
	#delay {3} {
		=drop all;
		#3 mpp;
		unkeep all corpse;
		#3 {get all;put all in box}
	}
}

#alias {studyrun}
{
	#nop use manually to donate, stock and study;
	#variable {resume_action} {%1};
	#delay {0.5} {
		go home;fantasy;portal;#15 e;leave;#4 e;#2 ne;n;#2 ne;e;#2 sw;portal;#8 n;
		#6 w;donateall;
		e;u;w;w;w;stockall;
		e;e;e;d;#5 e;
		#nop at rr;
		#if {$nset[study_on]} {
			form_study
		} {
			end_run
		}
	}
}

#alias {form_study}
{
	#switch {"$nset[form]"} {
		#case "lich" {
			#5 w;d;w;d;ne;n;n;d;enter gate;e;enter
		};
		#case "pure" {

		};
		#case "vampire" {

		};
		#case "were" {
			#5 w;d;w;sw;sw;se;s;u;nw;nw;path;sw;w
		};
		#case "reaper" {

		};
		#default {
			#5 w;s
		}
	};
	studyall
}

#nop the study module attempts to study LASTPOWER, which fails and this action catches it and resumes movement
#action {^The power, LASTPOWER, does not exist}
{
	#switch {"$nset[form]"} {
		#case "lich" {
			w;w;enter gate;u;s;s;sw;u;e;u;#5 e
		};
		#case "pure" {

		};
		#case "vampire" {

		};
		#case "were" {
			e;ne;path;se;se;d;n;nw;ne;ne;e;u;#5 e
		};
		#case "reaper" {

		};
		#default {
			n;#5 e
		}
	};	
	end_run
}

#alias {on_repower}
{
	update_cooldown bloodarc 1;
	update_cooldown prime 1;
	update_cooldown unholyground 1;
	update_cooldown illume 1;
	update_cooldown soulbind 1;
	update_cooldown unholy ground 1;
	update_cooldown pyre 1;
	_repower_ipp
}

#action {^ | Comtrance:%*,} {#variable {comtrance} {%1}}
#action {^  Your comtrance is now set to '%*' master} {#variable {comtrance} {%1}}
#action {^You attack Zephira the Grimare.} {=halt}
#action {^%* howls in extreme pain from the titanic blast of energy!!} {#format {mobname} {%l} {%1}}
#action {^\/\/\/The protective spirits break away from your body, fading into nothingness} {protection}
#action {^Necromantic energy flows into your phylactery} {on_repower}
#action {^Coffin        [  %d/  %d|} {#variable {nset[coffin_max]} {%2}}

#action {^Raising your hands to the sky, you call forth the spirits of the underworld} {update_cooldown soulbind 0}
#action {^You scream with the power of the netherworld and thrust your hands toward} {update_cooldown unholyground 0}
#action {You are already under the effect of an unholy ground master} {update_cooldown unholyground 0}
#action {^You reach towards the dark clouds in the heavens and call forth} {update_cooldown bloodarc 0}
#action {You must wait until repower to attempt another bloodarc master} {update_cooldown bloodarc 0}
#action {^You are already illuminating} {update_cooldown illume 0}
#action {^You call upon the material planes of energy to power your soul!} {update_cooldown illume 0}
#action {^The magical illumination fades from your body.} {update_cooldown illume 1}
#action {^You begin to generate magical energy} {update_cooldown spark 1}
#action {^Your body relaxes from the strain} {update_cooldown spark 0}

#action {^%1 pokes you in the ribs}
{
	#if {@storedcorpses{} > 10 && $my[gp1][perc] > 30} {
		#if {$corpses[follower] > 0} {
			#send !=drop corpse
		}; #elseif {$corpses[cooler] > 0} {
			#send !uncooler corpse
		}; #elseif {$corpses[freezer] > 0} {
			#send !deslab
		}; #elseif {$corpses[coffin] > 0} {
			#send !unwrap
		}; #else {
			#send !drop corpse
		}
	}
}

#alias {on_mask_activated}
{
	#if {$ringdark_on} {
		ringlight
	}
}

#alias {on_mask_reclaimed}
{
	#if {$ringdark_on && $enemy[hp] > 10} {
		ringdark
	}
}

#nop HP[1952/2940] NP[57055/74600|1c] Grimare[100%/0c/21c] Memory[drm91]
#nop HP[2805/2805] NP[51518/74600|0c] Undead[none/19c] Memory[drm465]
#action {^{HP\[.+}} {process_hpbar {%0}}

#alias {process_hpbar}
{
	#nop allow mip to handle hp/sp updates, but only trigger off of NP values in this alias;

	#regexp {%1} {{NP\[(\d+)\/(\d+)\|(\d+)c\]}} {
		#var {my[gp1][current]}		{&2};
		#var {my[gp1][max]}			{&3};
		#var {corpses[inventory]}	{&4}
	};
	#regexp {%1} {{(?:\w+)\[(\d+)\%\/(\d+)c\/(\d+)c\]}} {
		#var {follower} {on};
		#var {corpses[follower]} {&3};
		#var {corpses[coffin]} {&4}
	} {
		#regexp {%1} {{Undead\[none\/(\d+)c\]}} {
			#var {follower} {off};
			#var {corpses[follower]} {0};
			#var {corpses[coffin]} {&2}
		}
	};
	#regexp {%1} {{drm(\d+)}} {
		#var {my[powers][heal]} {&2}
	};
	#regexp {%1} {{alt(\d+)}} {
		#var {my[powers][heal]} {&2}
	};
	#regexp {%1} {{ssh(\d+)}} {
		#var {my[powers][heal]} {&2}
	};

	#math {my[gp1][perc]} {$my[gp1][current] * 100 / $my[gp1][max]};
	update_status_bar;

	#if {$my[worth] < 125} {
		#math {con_amount} {(125-$my[worth]) * 20};
		#if {$con_amount > 200} {#variable $con_amount 200};
		#send !con $con_amount
	};

	#if {"$my[prot]" == "OFF"} {
		#send !protection
	};

	#nop it's assumed the mask module is being used, even if there's no mask or it's turned off it still provides enhanced functionality;
	#if {($my[gp1][perc] < 50) && ($enemy[hp] > 5)} {
		#if {$recently_reclaimed == 0} {
			#if {$my[gp1][perc] <= 20} {
				#delay {reclaim} {mu 5} {0.1}
			};#elseif {$my[gp1][perc] <= 30} {
				#delay {reclaim} {mu 4} {0.1}
			};#elseif {$my[gp1][perc] <= 40} {
				#delay {reclaim} {mu 3} {0.1}
			};#else {
				#delay {reclaim} {mu 2} {0.1}
			}
		}
	};

	#nop only do automated guild runs if we are stepping;
	#if {$guildruns_on == 1 && $mip[round] > 0 && $bot == 1 && $halt == 0} {

		#nop check reagents - doante, stock and study if low;
		#if {$my[rg][ginseng] < 50 || $my[rg][goldenrod] < 50} {
			prep_guildrun
		};

		#nop check dreams remaining - doante, stock and study if low;
		#if {$nset[study_on] == 1 && $nset[heals_low] > 0 && $my[powers][heal] < $nset[heals_low]} {
			prep_guildrun
		};

		#nop check corpse count - doante, stock, store and study if overflowing;
		#if {$corpseruns_on == 1} {
			#if {$corpses[coffin] >= ($nset[coffin_max]-1) && ("$freezer" != "on" || $corpses[freezer] >= 49) && ("$cooler" != "on" || $corpses[cooler] >= 49)} {
				prep_guildrun
			}
		};
		#elseif {$corpseruns_on == 2 && @storedcorpses{} < 10} {
			#nop corpse pickup;
			#nop prep_guildrun
		};

		#nop if the last con failed due to no coins, prep a guildrun;
		#if {$low_coins} {
			prep_guildrun
		}
	};

	#if {$ipp_charge == 0} {
		update_cooldown prime 0;
	};

	#path get length path_len;
	#path get position path_pos
}

#alias {prep_guildrun}
{
	#if {$halting == 0} {
		#variable halting 1;
		.stop;
		onk #delay {4} {#if {$:mip[round] == 0} {onk clear;#variable halting 0;guildrun}}
	}
}

#alias {update_status}
{
	#nop do not perform any actions from update_status as mip data is unreliable and it this alias fires several times a round;
	#math {my[gp1][perc]} {$my[gp1][current] * 100 / $my[gp1][max]};
	#math {my[hp][perc]} {$my[hp][current] * 100 / $my[hp][max]};

	#var {my[hp][graph]}	{@graph{$my[hp][current];$my[hp][max]}};
	#var {my[sp][graph]}	{@graph{$my[sp][current];$my[sp][max]}};
	#var {my[gp1][graph]}	{@graph{$my[gp1][current];$my[gp1][max]}};
	#var {enemy[graph]}		{@graph{$enemy[hp];100}};
	#format {hp}			{%+5s} {@colscale{$my[hp][current];$my[hp][max]}};
	#format {hp_max}		{%-5s} {<128>$my[hp][max]<088>};
	#format {sp}			{%+4s} {@colscale{$my[sp][current];$my[sp][max]}};
	#format {sp_inf}		{%+3s} {<168>$my[sp][fuse][current]<088>};
	#format {sp_max}		{%+4s} {<128>$my[sp][max]<088>};

	#math {np_k} 			{$my[gp1][current] / 1000};
	#math {np_max_k} 		{$my[gp1][max] / 1000};
	#format {np}			{%+3s${scol}k<088>} {@colscale{$np_k;$np_max_k}};
	#format {np_max}		{<128>%-4s<088>} {${np_max_k}${scol}k};

	#format {corpsestatus} {<eea>%s<088>/<aff>%s<088>/%s<088>/%s<088>/%s<088>} {$corpses[inventory]} {$corpses[coffin]} {@onoffnumbercolour{$freezer;<afc>;$corpses[freezer]}} {@onoffnumbercolour{$cooler;<acf>;$corpses[cooler]}} {@onoffnumbercolour{$follower;<eae>;$corpses[follower]}};
	#format {roundcount} {%s} {$mip[round]};
	#format {gstatus} {<088>%sC%sM%sS%s%s%sH%sR ${scol}[%sG%sC${scol}]<088>} {@statuscolour{$corpsetrig_on}} {@statuscolour{$mask_on}} {@statuscolour{$scalers_enabled}} {@statuscolour{$combat_que_on}} {$area_rating} {@statuscolour{$global_hardmode}} {@statuscolour{$ringdark_on}} {@statuscolour{$guildruns_on}} {@statuscolour{$corpseruns_on}};
	#format {botstatus} {%+3s/%-3s} {$path_pos} {$path_len};

	#if {$nset[study_on]} {
		#variable {powerstatus} { ${scol}DR:@colscale{$my[powers][dream];700}}
	} {
		#variable {powerstatus} {}
	};

	#line ignore #showme {${scol}HP:$hp/$hp_max ${scol}SP:$sp/$sp_max  ${scol}NP:$np/$np_max   ${scol}BS:<088>$botstatus    ${scol}DA:@colscale{$dmg[cur][rnd];10000}$powerstatus} {-4};
	#line ignore #showme {${scol}HP:$my[hp][graph]  ${scol}SP:$my[sp][graph] ${scol}NP:$my[gp1][graph]  ${scol}EH:$enemy[graph] ${scol}RC:<088>$roundcount} {-3};

	#if {$mip[round] == 0} {update_status_bar};
}

#alias {update_status_bar}
{
	#format {statusbar} {${scol}WO:%s${scol}\% ${scol}TP:%s ${scol}FG:%s ${scol}PR:%s ${scol}RP:%s${scol}\% ${scol}UF:%s${scol}\% ${scol}CC:$corpsestatus <088>$gstatus ${scol}(<add>%s${scol})<088> %s} {@colscale{$my[worth];120}} {@colscale{$my[ports][current];5}} {@colscale{$my[glamors][current];9}} {@onoffcolour{$my[prot]}} {@colscale{$my[repower];100}} {@colscale{$my[undead];100}} {$comtrance} {$onkill};
	#line ignore #showme {$statusbar} {-6};
}

#alias {corpsetrig}
{
	#nop corpse gathering handled by ktrig, do everything else here;
	#if {$nset[ktrig_on] == 0} {
		#send !qtrance $ktrig
	};
	#if {$combat_que_on} {cq refresh};
	#if {$corpsetrig_on} {
		#if {$corpsetrig_on == 2} {#send !divvy coins} {#send !get coins};
		#if {$backpack_module} {stacknext} {#send !get all}
	} {
		#send !divvy coins
	};
	#if {$onkill_module} {onkillrun};
	#delay {3} {ktrigsetup}
}

/* Preserve all */
#variable preserving 0

#alias {mpp}
{
	#var preserving 1;
	#var preserve_np 0;
	#var preserve_done 0;
	qtrance preserve remains>20
}

#act {^You only have %d/%d necromantic points for that.} {
	#if {$preserving} {
		#var preserve_np 1
	}
}
#act {^That corpse is already preserved master.} {
	#if {$preserving} {
		#var preserve_done 1
	}
}
#act {^There is no corpse in this room master.} {
	#if {$preserving} {
		#var preserve_done 1
	}
}

#act {^You recover your senses} {
	#if {$preserving} {
		#if {$preserve_np} {
			absorb;
			mpp
		}; #elseif {$preserve_done} {
			#var preserving 0
		}; #else {
			mpp
		}
	}
}

#alias {stockall}
{
	#foreach {*my[rg][%*]} {reagent} {
		#local {tobuy} {};
		#local {maxstock} {999};
		#local {uom} {100};

		#if {"$reagent" == "bloodmoss"} 
		{
			#variable {maxstock} {20};
			#variable {uom} {10}
		};

		#math {tobuy} {$maxstock - $my[rg][$reagent]};

		#while {$tobuy > 0}
		{
			#if {$tobuy > $uom}
			{
				#send {buy $uom $reagent}
			} {
				#send {buy $tobuy $reagent}
			};
			#math {tobuy} {$tobuy - $uom}
		}
	}
}

#nop Override the alias from mip.tin to suit the changed configuration - see header notes for more details
#alias {.mipProcessGlineNecromancer} {
	#if {%1 == 1} {
		#REGEX {$mip[gline][1]} {C:%d}			{#VAR {corpses[inventory]} {&1}};
		#REGEX {$mip[gline][1]} {Worth:%d}		{#VAR {my[worth]} {&1}};
		#REGEX {$mip[gline][1]} {Tport:%d/%d}	{#VAR {my[ports][current]} {&1};#VAR {my[ports][max]} {&2}};
		#REGEX {$mip[gline][1]} {Sprk:%d/%d}	{#VAR {my[glamors][current]} {&1};#VAR {my[glamors][max]} {&2}};
		#REGEX {$mip[gline][1]} {Repower:%d}	{#VAR {my[repower]}	{&1}};
		#REGEX {$mip[gline][1]} {{Prot:(ON|OFF)}} {#VAR {my[prot]} {&2}};
		#REGEX {$mip[gline][1]} {Circle:%f}		{#VAR {my[gxp]} {&1}};
		#REGEX {$mip[gline][1]}	{Undead:%d}		{#VAR {my[undead]} {&1}};
		#REGEX {$mip[gline][1]}	{SPf:%d/%d}		{#VAR {my[sp][fuse][current]} {&1};#VAR {my[sp][fuse][max]}	{&2}}
	}; #elseif {%1 == 2} {
		#REGEX {$mip[gline][2]} {G:%d} {#VAR {my[rg][ginseng]} {&1}};
		#REGEX {$mip[gline][2]} {P:%d} {#VAR {my[rg][black pearl]} {&1}};
		#REGEX {$mip[gline][2]} {W:%d} {#VAR {my[rg][spider web]} {&1}};
		#REGEX {$mip[gline][2]} {R:%d} {#VAR {my[rg][goldenrod]} {&1}};
		#REGEX {$mip[gline][2]} {M:%d} {#VAR {my[rg][mandrake]} {&1}};
		#REGEX {$mip[gline][2]} {N:%d} {#VAR {my[rg][pine needle]} {&1}};
		#REGEX {$mip[gline][2]} {S:%d} {#VAR {my[rg][nightshade]} {&1}};
		#REGEX {$mip[gline][2]} {B:%d} {#VAR {my[rg][bloodmoss]} {&1}}
	}; #else {
		#ECHO {<171> Invalid Gline Number <088>}
	}
} {1}

#class {necromancer} {close}
