#nop necromancer.tin
/*
GETTING STARTED
	Grab all the required modules and place into .tt/3k/modules
	Replace necromancer.tin with this one in .tt/3k/guilds
	Add the smithy.tin bot to .tt/3k/bots
	Follow the guild setup section below
	Verify everhthing loads correctly on login
	Use the nset command to configure your settings - super important!
	Enjoy!

REQUIRED MODULES
	You need to include the common.tin module in your **character** file.
		#read {.tt/3k/modules/common.tin}
		This will read/include the following modules:
			backpack.tin (uses by default 4 gentech backpacks)
			combat_que.tin
			mask.tin
			scalers.tin
			watchdog.tin
			onkill.tin
	You can use your own, or use the smithy.tin bot file

GUILD SETUP
	Using cconfigure, configure gline1 and gline2 as below, it doesn't matter if you add extras or less to gline1,
	however gline2 requires all the reagents for the stockall alias to work correctly.
	gline1: worth, powers, protection, repower, circle, fused, follower
	gline2: add all reagents
	
	HP Bar config, add the elements below to your bar, make sure Hit Points is first, and the others listed always remain on the first line of your hp bar.
	If you add more and it wraps, you add a new action for it down below in this file.
	
		1 [Hit Points]
  		2 [Necro Points/Corpses]
  		3 [Undead Follower/Coffin]
		4 [Memory] (drm)    Note: add alter if you are a werebeast, shapeshift if a vampire, or dream if you are a reaper/pure/lich. Only add one of the three types.

COMMANDS
	nset			- Configure various necromatic settings, 'nset help' for more details.
	cre/crd			- Enable/disable automatic corpse runs (dropoffs to Duncan)
	gre/grd			- Enable/disable automatic guild runs (low dreams)
	cte/ctd/ctp 	- Corpse trigger, enable/disable/enable party
	studyrun [arg]	- Run to the guild to study, execute arg when done
	storeall		- Use manually or automatically in guildruns to store all your corpses at duncan, excluding coffin by default
	cud				- Create an undead follower using the configured name and description from nset
	guildrun [arg]	- Used automatically or you can hit it manually to run to the guild to doante, study, restock and then restart the stepper.
					  If arg is supplied, arg will be executed when done instead of the default 'thisarea'
	
	studyrun [arg]  - Use manually to run to the guild to donate, stock and study. If arg is supplied it is executed when done.
	stockrun [arg]  - Use to manually run to the guild to donate and restock. If arg is supplied it is executed when done.
	gaghp			- Gag your HP bar, at least the line that starts with HP[.
	ungaghp			- Ungag your HP bar. Ungag if you have any issues with it triggering the status updates.
	ringson			- start using ring of light, ring of darkness for training angel rune.
					  keep both rings in your inventory and make sure the combat cue entry is in and enabled.
	ringlight		- swap to ring of light
	ringdark		- swap to ring of darkness

POWER STUDYING
	npowers 							- view list the configured powers for studying
	npowers add <name> <qty> <priority> - add a power to the list, where the priority 1 is the highest:
	npowers remove <name>				- remove a power from the list
	studyall							- begin studying the powers in ascending priority
		
	Notes:
		A Qty over 100 will be studied in blocks of 100 automatically.
		Name is all lowercase and must match exactly what you see in the
		power listing. If you have the qty memorised (or more) it's skipped.

		Define this action in the necromancer.tin file, adjust to suit:
			#action {^The power, LASTPOWER, does not exist} {xx;yy;.resume;etc}
					  
*/

#nop this file has my personal stuff in it, you can just ignore the failed read or make your own
#read {.tt/3k/guilds/necromancer_custom.tin}

#class {necromancer} {kill}
#class {necrosettings} {kill}
#class {necromancer} {open}

#alias {_nset_reset} {
	#echo {<258>Necromatic settings have been reset to default.<088>};
	#class {necrosettings} {kill};
	#class {necrosettings} {open};
	#variable {nset[study_on]} {1};
	#variable {nset[winch_on]} {1};
	#variable {nset[coffin_max]} {5};
	#variable {nset[form]} {lich};
	#variable {nset[ktrig_on]} {0};
	#variable {nset[invoke]} {power};
	#variable {nset[follower_name]} {};
	#variable {nset[follower_gender]} {};
	#variable {nset[follower_desc]} {};
	#variable {nset[follower_enter]} {};
	#variable {nset[follower_exit]} {};
	#variable {nset[follower_max]} {10};
	#variable {nset[heals_low]} {0};
	#variable {nset[stash_note1]} {};
	#variable {nset[stash_note2]} {};
	#variable {nset[inventory_max]} {5};
	#variable {nset[coins]} {10000};
	#variable {nset[bloodmoss]} {5};
	#variable {nset[gaghp]} {0};
	#variable {nset[circle]} {1};
	#variable {nset[teleport_mem]} {3};
	#variable {nset[hidden][teleport_1]} {0};
	#variable {nset[hidden][teleport_2]} {0};
	#variable {nset[hidden][teleport_3]} {0};
	#variable {nset[hidden][teleport_4]} {0};
	#variable {nset[hidden][teleport_5]} {0};
	#class {necrosettings} {close};
	#class {necrosettings} {save};
	#class {necrosettings} {write} {.tt/char/$ses_name-nset.tin};
}

#class {necrosettings} {read} {.tt/char/$ses_name-nset.tin}
#class {necrosettings} {size} {nsetsize};
#if {$nsetsize == 0} {
	#echo {<258>Necromatic settings file not found!<088>};
	_nset_reset;
	#unvariable {nsetsize}
}

#class {necropowerslist} {kill}
#class {necropowerslist} {read} {.tt/char/$ses_name-necropowers.tin}
#class {necropowerslist} {size} {nplsize};

#if {$nplsize == 0} {
	#echo {Power file not found, creating default.};
	#class {necropowerslist} {kill};
	#class {necropowerslist} {open};
	#variable {powerstudy} {};
	#class {necropowerslist} {close};
	#class {necropowerslist} {save};
	#class {necropowerslist} {write} {.tt/char/$ses_name-necropowers.tin};
	#unvariable {nplsize}
}

#variable {guild} {necromancer}
#variable {my[undead]} {0}
#variable {path_len} {0}
#variable {path_pos} {0}
#variable {halting} {0}
#variable {guildruns_on} {1}
#variable {corpseruns_on} {0}
#variable {scol} {<bbb>}
#variable {laststatusbar} {}
#variable {ringdark_on} {0}
#variable {ktrig} {wrap/preserve get}
#variable {low_coins} {0}
#variable {globes} {0}
#variable {memory} {0}
#variable {studying} {0}
#variable {nset_reset_count} {0}

#highlight {^You prepare the corpse with magical energies and store it away.} {yellow}
#highlight {^You prepare the corpse with your innate, necromantic energies.} {yellow}
#highlight {^The corpse is already preserved, but grabbing it anyway.} {yellow}
#highlight {^You chant softly, casting your own soul over the fallen.} {light yellow}

#gag {^The spirit touches the corpse and you watch it crystalize.  With the briefest}
#gag {^nudge, the frozen corpse shatters, releasing the magical energy to be joined}
#gag {^with your own.$}
#gag {^The aegis rune on the PsiMace pulses for a moment.}
#gag {^From afar, Death favors you.}
#gag {^Death tells you:}
#gag {^  I can feel you moving closer}
#gag {^  I can wait for you}
#gag {^  We will be together soon enough}
#gag {^  You escaped my grasp this time}
#gag {^  Live onward my}
#gag {^  Don't worry my %1, I always collect my debts}
#gag {^  %1, my %2, I will embrace you soon}
#gag {^  Your destiny will wait a bit longer}

#substitute {C:O=|======> } {}
#substitute {C:D=##====<E } {}
#substitute {^  My favor will cost you} {<218>Death tells you: <138>My favor will cost you}

#alias {nset}
{
	#if {"%1" == ""} {
		#local {nsetout} {};
		#format {nsetout} {<158> Setting             Value<088>} {$nsetout};
		#format {nsetout} {%s\n<258>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-<088>} {$nsetout};
		#foreach {*nset[%*]} {name} {
			#if {"$name" != "hidden"} {
				#format {nsetout} {%s\n <258>%-20s<088> %.55s} {$nsetout} {$name} {$nset[$name]}
			}
		};
		#echo {$nsetout}
	};
	#elseif {"%1" == "reset"} {
		#if {$nset_reset_count == 0} {
			#echo {<258>Are you sure you wish to reset your necromatic settings?\nType <158>nset reset<258> again within 10 seconds to confirm.<088>};
			#variable {nset_reset_count} {1};
			#delay {nset_reset} {
				#variable {nset_reset_count} {0};
				#echo {<258>Necromatic settings reset period has timed out.<088>}
			} {10}
		} {
			#variable {nset_reset_count} {0};
			_nset_reset
		}				
	};
	#elseif {"%1" == "help"} {
		#local {nsetout} {};
		#format {nsetout} {<158> Setting              Description<088>} {$nsetout};
		#format {nsetout} {%s\n<258>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-<088>} {$nsetout};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {bloodmoss}		{Your desired bloodmoss stock quantity};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {coffin_max}		{Your coffin's max corpse capacity};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {circle}			{Show your Circle % on the status bar};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {coins}			{Number of coins to carry around after a guildrun};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {heals_low}		{If guildruns on, study when form heal < this. 0 = disable};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_desc}	{Your follower's description for use with the cud alias};		
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_enter}	{Your follower's enter message for use with the cud alias};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_exit}	{Your follower's exit message for use with the cud alias};		
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_gender}{Your follower's gender for use with the cud alias};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_max}	{Your follower's max corpse capacity};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {follower_name}	{Your follower's name for use with the cud alias};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {form}			{Your necromatic form, for paths and setting configs};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {gaghp}			{Your default HP bar gag state. Ungag if things don't update};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {inventory_max}	{Your max corpse capacity, help prevent overburden};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {invoke}			{Set to your default/preferred invoke dmg type};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {ktrig_on}		{Handle corpses using the ktrig vaf instead of qtrance};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {reset}			{Reset all settings to their defaults};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {stash_note1}	{Roomnote for your 1st corpse stash for auto restocking};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {stash_note2}	{Roomnote for your 2nd corpse stash for auto restocking};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {study_on}		{Turn on\/off study runs, respect\/ignore heals_low};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {teleport_mem}	{Your number of teleport memory positions};
		#format {nsetout} {%s\n <258>%-20s<088> %s} {$nsetout} {winch_on}		{Use the rolm for guildruns instead of running};
		#echo {$nsetout}
	};
	#else {
		#regexp {%0} {{(teleport_mem|circle|gaghp|bloodmoss|winch_on|ktrig_on|study_on|invoke|follower_name|follower_gender|follower_desc|follower_enter|follower_exit|follower_max|coffin_max|inventory_max|form|heals_low|stash_note1|stash_note2|coins) ([a-zA-Z0-9\._\'\s\-]+)}} {
			#regexp {&3} {{@_nset_format{&2}}} {
				#if {"&3" == "clear"} {
					#nop for freeform text entries, they can be cleared with the clear argument;
					#variable {nset[&2]} {};
					#echo {<258>Necromatic setting <158>&2<258> has been <158>cleared<258>.<088>}
				} {
					#variable {nset[&2]} {&3};
					#echo {<258>Necromatic setting <158>&2<258> set to <158>&3<258>.<088>}
				};
				_nset_save;
			} {
				#echo {<258>Invalid nset value <158>&3<258> for <158>&2<258>.<088>}
			}			
		} {
			#echo {<258>Syntax is <158>nset <option> <value><258>.<088>}
		}
	}
}

#function {_nset_format}
{
	#if {"%1" == "circle" || "%1" == "gaghp" || "%1" == "ktrig_on" || "%1" == "study_on" || "%1" == "winch_on"} {
		#nop 0-1;
		#variable result ([0-1])
	};
	#elseif {"%1" == "bloodmoss" || "%1" == "inventory_max" || "%1" == "coffin_max"} {
		#nop 1-999;
		#variable result ([1-9][0-9]{0,2})
	};
	#elseif {"%1" == "heals_low"} {
		#nop 0-999;
		#variable result ([0-9]{0,3})
	};
	#elseif {"%1" == "coins"} {
		#nop 1 to 999999;
		#variable result ([1-9][0-9]{0,5})
	};
	#elseif {"%1" == "form"} {
		#variable result (lich|pure|reaper|were|vampire)
	};
	#elseif {"%1" == "follower_gender"} {
		#variable result (male|female|neuter)
	};
	#elseif {"%1" == "invoke"} {
		#variable result (edged|crushing|cold|flame|psionic|lightning|corrosion|virulence|power|light)
	};
	#else {
		#nop text;
		#variable result (.+)
	}
}

#nop used internally for resetting boot-long settings 
#alias {_nset_clear}
{
	#variable {nset[hidden][teleport_1]} {0};
	#variable {nset[hidden][teleport_2]} {0};
	#variable {nset[hidden][teleport_3]} {0};
	#variable {nset[hidden][teleport_4]} {0};
	#variable {nset[hidden][teleport_5]} {0};
	_nset_save
}

#alias {_nset_save}
{
	#class {necrosettings} {write} {.tt/char/$ses_name-nset.tin}
}

#nop called from common.tin module when you log in
#alias {on_guild_login}
{
	_nset_clear;
	startwatchdog;
	#if {$nset[gaghp]} {gaghp} {ungaghp};
	jump;w;home;mapgo home;
	dungeons;
	cq load;cq on;
	cip;hp;gs;
	#delay {4} {ktrigsetup}
}

#nop called from common.tin module whenever you reconnect
#alias {on_guild_reconnect}
{
	startwatchdog;
	#if {$nset[gaghp]} {gaghp} {ungaghp};
	#nop keep all these items to enable/disable scripts for them;
	keep coffin;keep morgue;keep cooler;keep mask;keep cocoon;
	cc;
	dungeons;
	touch diamond rune;
	cq load;cq on;
	hp;gs;
	#delay {4} {ktrigsetup}
}

#alias {on_kshield_equip}
{
	#send !repeat combat/bash/0/0
}

#alias {on_kshield_remove}
{
	#send !repeat off
}

#nop setup combat que - no longer required but maintained for backup
#alias {cq_setup}
{
	cq clear;
	cq add ewell/8/start/990/0/(energy well;
	cq add raven/9/start/0/0/touch raven rune;
	cq add owl/8/end/0/0/touch owl rune;
	cq add bloodarc/8/start/500/0/barc;
	cq add familiar/0/start/0/0/call;
	cq add prime/6/start/501/0/prime;
	cq add unholyground/7/med/0/0/unholy ground;
	cq add illume/1/any/0/1/illume/@:check_glamor{gp1;80};
	cq add conjure/0/start/0/0/conjure undead;
	cq add soulbind/9/start/0/0/soulbind;
	cq add rings/0/start/300/0/ringdark;
	cq disable rings;
	cq on
}

#nop flexible function for form glamors with the combat que, e.g. @check_glamor{gp1;80}
#function {check_glamor}
{
	#if {$my[%1][perc] < %2 && $my[glamors][current] > 0} {
		#variable result 1
	} {
		#variable result 0
	}
}

#alias {gaghp}
{
	#gag {^HP[};
	#gag {^C:HP[};
	#echo {<258>HP Bar gagged. If you experience any issues with things not updating, ungag with ungaghp.<088>}
}

#alias {ungaghp}
{
	#ungag {^HP[};
	#ungag {^C:HP[};
	#echo {<258>HP Bar un-gagged.<088>}
}

#alias {a} {#send !absorb}
#alias {aa} {#send !absorb prime}
#alias {p} {#send !preserve}
#alias {pg} {#send !preserve get}
#alias {ug} {#send !unholy ground}
#alias {sb} {#send !soulbind}
#alias {barc} {#send !bloodarc $mobname}

#alias {npr} {#send !nocturnum prime}
#alias {dpr} {#send !diurnum prime}
#alias {da} {#send !detect alignment}
#alias {ng} {#send !necrogram}
#alias {com} {#send !chat}
#alias {comm} {#send !chat}
#alias {ka} {#send !kill a}
#alias {kb} {#send !kill b}
#alias {kc} {#send !kill c}
#alias {kd} {#send !kill d}
#alias {ke} {#send !kill e}
#alias {kf} {#send !kill f}
#alias {kg} {#send !kill g}
#alias {kh} {#send !kill h}
#alias {ki} {#send !kill i}
#alias {kj} {#send !kill j}
#alias {kk} {#send !kill k}
#alias {kl} {#send !kill l}
#alias {km} {#send !kill m}
#alias {kn} {#send !kill n}
#alias {ko} {#send !kill o}
#alias {kp} {#send !kill p}
#alias {kq} {#send !kill q}
#alias {kr} {#send !kill r}
#alias {ks} {#send !kill s}
#alias {kt} {#send !kill t}
#alias {ku} {#send !kill u}
#alias {kv} {#send !kill v}
#alias {kw} {#send !kill w}
#alias {kx} {#send !kill x}
#alias {ky} {#send !kill y}
#alias {kz} {#send !kill z}

#alias {cip} {#send !comtrance invoke power}
#alias {cie} {#send !comtrance invoke edged}
#alias {cic} {#send !comtrance invoke crushing}
#alias {cim} {#send !comtrance invoke psionic}

#alias {gre} {#variable {guildruns_on} {1};#echo {Guildruns enabled.}}
#alias {grd} {#variable {guildruns_on} {0};#echo {Guildruns disabled.}}
#alias {cre} {#variable {corpseruns_on} {1};#echo {Corpse run drop-offs enabled.}}
#alias {crp} {#variable {corpseruns_on} {2};#echo {Corpse run pick-ups enabled.}}
#alias {crd} {#variable {corpseruns_on} {0};#echo {Corpse runs disabled.}}

#alias {donateall} {donate all;#if {$backpack_module} {donatebpall}}
#alias {sellall} {sell all;#if {$backpack_module} {sellbpall}}

#alias {cud}
{
	#send !unwrap;animate dead;chant;study tome;=lead;
	#if {"$nset[follower_name]" != ""}   {=name $nset[follower_name]};
	#if {"$nset[follower_gender]" != ""} {=gender $nset[follower_gender]};
	#if {"$nset[follower_desc]" != ""}   {=describe $nset[follower_desc]};
	#if {"$nset[follower_enter]" != ""}  {=setmin $nset[follower_enter]};
	#if {"$nset[follower_exit]" != ""}   {=setmout $nset[follower_exit]}
}

#alias {ktrigsetup}
{
	#local {new_ktrig} {};

	#if {$corpses[coffin] < $nset[coffin_max]} {
		#nop coffin has space;
		#local {new_ktrig} {keep all corpse/wrap}
	} {
		#nop coffin is full;
		#if {"$freezer" == "on" && $corpses[freezer] < 50} {
			#nop freezer has space, keep wrapping though to get the biggest corpses in the coffin;
			#local {new_ktrig} {keep all corpse/wrap/slab}
		} {
			#nop freezer is full;
			#if {"$cooler" == "on" && $corpses[cooler] < 50} {
				#nop cooler has space;
				#local {new_ktrig} {keep all corpse/preserve get/cooler corpse}
			} {
				#nop cooler is full or not enabled;
				#if {$my[undead] > 0 && $corpses[follower] < 24} {
					#nop undead has space;
					#local {new_ktrig} {preserve/=get corpse}
				} {
					#nop undead is full (or not summoned);
					#local {new_ktrig} {preserve get}
				}
			}
		}
	};

	#if {$ringdark_on} {
		#local {new_ktrig} {remove ring of darkness/wear ring of light/$new_ktrig}
	};

	#if {"$new_ktrig" != "$ktrig"} {
		#variable {ktrig} {$new_ktrig};
		#if {$nset[ktrig_on]} {
			#send !ktrig $ktrig
		}
	}
}

#alias {ringson}
{
	#variable {ringdark_on} {1};
	cq enable rings;
	#gag {^You are infused with the spirit as you don the item.};
	#gag {^The spirit fades from your grasp as you remove the item.};
	#gag {^The moment you remove the ring, the cloak of darkness surrounding};
	#gag {you disperses.  In but a few seconds, no evidence exists of its};
	#gag {presence.$};
	#gag {^The Ring sparkles into color, eventually stabilizing into a faint white};
	#gag {light which permits you to see far ahead.};
	#gag {^The light from the ring disappears the instant it is removed from};
	#gag {your finger.$};
	#gag {^As you don the ring, the air about you coalesces into a deep, soft};
	#gag {blackness.  The darkness swirls about your being until light seems};
	#gag {but a distant memory.$};
	ringlight;
	#delay {0.5} {ktrigsetup}
}
#alias {ringsoff}
{
	#variable {ringdark_on} {0};
	cq disable rings;
	#ungag {^You are infused with the spirit as you don the item.};
	#ungag {^The spirit fades from your grasp as you remove the item.};
	#ungag {^The moment you remove the ring, the cloak of darkness surrounding};
	#ungag {you disperses.  In but a few seconds, no evidence exists of its};
	#ungag {presence.$};
	#ungag {^The Ring sparkles into color, eventually stabilizing into a faint white};
	#ungag {light which permits you to see far ahead.};
	#ungag {^The light from the ring disappears the instant it is removed from};
	#ungag {your finger.$};
	#ungag {^As you don the ring, the air about you coalesces into a deep, soft};
	#ungag {blackness.  The darkness swirls about your being until light seems};
	#ungag {but a distant memory.$};
	ringlight;
	#delay {0.5} {ktrigsetup}
}
#alias {ringlight} {remove ring of darkness;wear ring of light}
#alias {ringdark} {remove ring of light;wear ring of darkness}

#nop handy alias when you first login
#alias {suitup}
{
	jump;e;home;morgue;acquire coffin;home;bank;deposit all;withdraw $nset[coins];home;
	chaos;enter;s;s;w;w;enter;n;n;n;n;buy moon rocks;s;s;s;s;leave;e;e;n;n;vortex;home;
	mapgo home;keep all
}

#nop called right before the watchdog tries to resume
#alias {on_watchdog_resume}
{
	#if {$ringdark_on} {ringlight}
}

#nop handle lord stanley's cup hockey fan corpses
#alias {on_hockey_fan}
{
	#if {$ringdark_on} {
		#local {go_dark} {1};
		ringlight;
	};
	#if {$my[gp1][perc] == 100 && $my[hp][perc] < 100}
	{
		#send !qtrance preserve/absorb prime
	} {
		#send !qtrance preserve/absorb
	};
	#if {$go_dark} {
		ringdark;
	}
}

#nop called from steppers at the very start to configure things
#alias {guildsetup}
{
	.stop;
	dungeons;
	#if {$combat_que_module} {
		rate run
	};
	#if {$scalers_module} {
		scaler run
	};

	#nop triger .resume from examining the satchel to allow things to catch up;
	#delay {2} {#send !examine crafter's satchel}
}

#action {^This leather satchel was issued to you}
{
	#if {$bot == 1} {
		#if {$bot_debug} {
			update_chat Starting $bots[stepper]: Dreams[$my[powers][dream]] Corpses[$corpsestatus]
		};
		#delay {1} {.resume}
	}
}

#nop start the corpse store process at duncan
#alias {storeall}
{
	=summon;
	examine duncan
}
#action {^Duncan is the keeper over the ancient necromantic crypts}
{
	deslab all;
	#if {"%1" != ""} {unwrap all};
	#if {$corpses[follower] > 0} {
		=drop all;
	};
	#if {"$cooler" == "on"} {
		#$corpses[cooler] uncooler corpse
	};
	#if {$mask_module == 1 && "$mask_glyph_state" != "unknown"}
	{
		mask all;
		#if {"$mask_glyph_state" == "off"} {trace glyph};
		#delay {4} {
			#variable {autostoreall} {1};
			mask on;
			get all;store all
		}
	} {
		#variable {autostoreall} {1};
		get all;store all
	}
}
#action {^Duncan says: Thank you for donating}
{
	#if {$autostoreall} {
		get all;store all
	}
}
#action {^Duncan says: The guild is extremely pleased!}
{
	#if {$autostoreall} {
		get all;store all
	}
}
#action {^Duncan says: But you don't have any corpses}
{
	#if {$autostoreall} {
		#variable {autostoreall} {0};
		e;u;#5 e;
		#nop at rr;
		#if {$nset[study_on]} {form_study} {end_run}
	}
}

#action {^  You do not have %1 gold coins to contribute master.}
{
	#variable {low_coins} {1};
}

#action {^You hand %1 coins to %2, who then %3 to the guild.}
{
	#variable {low_coins} {0};
}

#nop restock run betwen steppers using smithy.tin - resume safe
#alias {startrun}
{
	.stop;home;
	#delay {0.5} {guildrun .resume}
}

#nop automatic or manual use to trigger a guildrun
#alias {guildrun}
{
	#nop restock and corpse/item donate;
	#nop restart the stepper rather than resume to avoid piling up monsters or hitting blockers;
	#if {"%1" == ""} {
		#variable {resume_action} {thisarea}
	} {
		#variable {resume_action} {%1}
	};
    .stop;
	#if {$nset[winch_on]} {touch winch rune} {go home};
	#delay {0.5} {
		bank;deposit all;withdraw $nset[coins];home;
		fantasy;portal;#15 e;leave;#4 e;#2 ne;n;#2 ne;e;#2 sw;portal;#8 n;
		#6 w;donateall;
		e;u;#3 w;stockall;
		#3 e;d;#5 e;
		#nop at rr;
		#if {$corpseruns_on == 1} {
			#5 w;d;w;storeall
		} {
			#if {$nset[study_on]} {form_study} {end_run}
		}
	}
}

#nop use manually to donate, stock and study
#alias {studyrun}
{
	#variable {resume_action} {%1};
	go home;
	#delay {0.5} {
		fantasy;portal;#15 e;leave;#4 e;#2 ne;n;#2 ne;e;#2 sw;portal;#8 n;
		#6 w;donateall;
		e;u;w;w;w;stockall;
		e;e;e;d;#5 e;
		#nop at rr;
		#if {$nset[study_on]} {form_study} {end_run}
	}
}

#nop use manually to donate and restock
#alias {stockrun}
{
	#variable {resume_action} {%1};
	go home;
	fantasy;portal;#15 e;leave;#4 e;#2 ne;n;#2 ne;e;#2 sw;portal;#8 n;
	#6 w;donateall;
	e;u;w;w;w;stockall;
	e;e;e;d;#5 e;
	#nop at rr;
	end_run
}

#nop internal use to finish the guildruns
#alias {end_run}
{
	#nop starting at receiving room;
	#8 s;portal;ne;ne;e;e;portal;home;smithy;
	mapgo smithy;
	fix all;
	hp;
	#variable {low_coins} {0};
	#delay {2} {examine dwarf}
}

#nop use the dwaft in the smithy as a timing mechanism to let everything catch up before resuming/restarting
#action {^This rough looking dwarf looks at you cunningly with eyes of stone}
{
    #if {"$resume_action" != ""} {
        #echo {Resuming via '$resume_action'.};
        #delay {0.5} {$resume_action}
    }
}

#nop work in progress
#alias {corpse_unstash}
{

}

#alias {stash1}
{
	#if {"$nset[stash_note1]" != ""} {
		go $nset[stash_note1];
		corpse_stash;
	} {
		#echo {<258>Stash skipped as <158>stash_note1<258> has not been nset.<088>}
	}
}

#alias {stash2}
{
	#if {"$nset[stash_note2]" != ""} {
		go $nset[stash_note2];
		corpse_stash;
	} {
		#echo {<258>Stash skipped as <158>stash_note2<258> has not been nset.<088>}
	}
}

#nop work in progress
#alias {corpse_stash}
{
	deslab all;
	mask active;
	#delay {3} {
		=drop all;
		#5 mpp;
		unkeep all corpse;
		#5 {get all;put all in box};
		mask on;
		on_corpses_stashed;
		#delay {3} {ktrigsetup}
	}
}

#nop override this alias to perform a custom action
#alias {on_corpses_stashed} { } {9}

#nop directions to the form libraries from RR
#alias {form_study}
{
	#switch {"$nset[form]"} {
		#case "lich" {
			#5 w;d;w;d;ne;n;n;d;enter gate;e;enter
		};
		#case "pure" {

		};
		#case "vampire" {

		};
		#case "were" {
			#5 w;d;w;sw;sw;se;s;u;nw;nw;path;sw;w
		};
		#case "reaper" {

		};
		#default {
			#5 w;s
		}
	};
	studyall
}

#alias {on_repower}
{
	update_cooldown bloodarc 1;
	update_cooldown prime 1;
	update_cooldown unholyground 1;
	update_cooldown illume 1;
	update_cooldown spark 1;
	update_cooldown soulbind 1;
	update_cooldown unholy ground 1;
	update_cooldown pyre 1;
	update_cooldown conjure 1;

	_repower_ipp
}

#action {^ | Comtrance:%*,} {#variable {comtrance} {%1}}
#action {^  Your comtrance is now set to '%*' master} {#variable {comtrance} {%1}}
#action {^You attack %1 the Grimare.} {=halt}
#action {^%* howls in extreme pain from the titanic blast of energy!!} {#format {mobname} {%l} {%1}}
#action {^\/\/\/The protective spirits break away from your body, fading into nothingness} {protection}
#action {^Necromantic energy flows into your phylactery} {on_repower}
#action {^Coffin        [  %d/  %d|} {#variable {nset[coffin_max]} {%2}}

#nop combat que cooldown management
#action {^Raising your hands to the sky, you call forth the spirits of the underworld} {update_cooldown soulbind 0}
#action {^You scream with the power of the netherworld and thrust your hands toward} {update_cooldown unholyground 0}
#action {^  You are already under the effect of an unholy ground master} {update_cooldown unholyground 0}
#action {^You reach towards the dark clouds in the heavens and call forth} {update_cooldown bloodarc 0}
#action {^  You must wait until repower to attempt another bloodarc master} {update_cooldown bloodarc 0}

#action {^You call upon the material planes of energy to power your soul!} {update_cooldown illume 0}
#action {^You are already illuminating} {update_cooldown illume 0}
#action {^The magical illumination fades from your body.} {update_cooldown illume 1}
#action {^You are already sparking} {update_cooldown spark 0}
#action {^You begin to generate magical energy} {update_cooldown spark 0}
#action {^Your body relaxes from the strain} {update_cooldown spark 1}

#action {^  You are only able to conjure %1 undead per repower master} {update_cooldown conjure 0}
#action {^  You must have at least one %1 to invoke a soulbind master} {update_cooldown soulbind 0}
#action {^  You have already invoked a soulbind this repower master} {update_cooldown soulbind 0}

#nop teleport helpers
#alias {tp}  {teleport}
#alias {tpl} {teleport list}
#alias {tp1} {teleport 1}
#alias {tp2} {teleport 2}
#alias {tp3} {teleport 3}
#alias {tp4} {teleport 4}
#alias {tp5} {teleport 5}
#alias {ts1} {#send !teleport set 1}
#alias {ts2} {#send !teleport set 2}
#alias {ts3} {#send !teleport set 3}
#alias {ts4} {#send !teleport set 4}
#alias {ts5} {#send !teleport set 5}
#alias {teleport}
{
	#variable {teleport_recall} {0};

	#regexp {%0} {^%d$} {
		#if {&1 > 0 && &1 <= $nset[teleport_mem]} {
			#variable {teleport_recall} {&1}
		}
	};
	#send !teleport %0
}

#action {^  This room is set to teleport position %1.}
{
	#variable {nset[hidden][teleport_%1]} {$roomvnum};
	_nset_save;
	#delay {0} {#echo {<258>You set room <158>$roomvnum<258> for teleport position <158>%1<258>.<088>}}
}

#action {^Visions of the guild appear first in your mind, then reality...}
{
	#nop this is the default vnum for the receiving room, change if yours is different;
	#map go 7549
}

#action {^The illusions clear from your mind and you find yourself there.}
{
	#if {$teleport_recall > 0 && $nset[hidden][teleport_$teleport_recall] > 0}
	{
		#map go $nset[hidden][teleport_$teleport_recall];
		#variable {teleport_recall} {0};
		#delay {0} {#echo {<258>You recall room <158>$roomvnum<258> for teleport position <158>$teleport_recall<258>.<088>}}
		
	}
}


#action {^%1 pokes you in the ribs}
{
	#if {@storedcorpses{} > 10 && $my[gp1][perc] > 30} {
		#if {$corpses[follower] > 0} {
			#send !=drop corpse
		}; #elseif {$corpses[cooler] > 0} {
			#send !uncooler corpse
		}; #elseif {$corpses[freezer] > 0} {
			#send !deslab
		}; #elseif {$corpses[coffin] > 0} {
			#send !unwrap
		}; #else {
			#send !drop corpse
		}
	}
}

#alias {on_mask_activated}
{
	#if {$ringdark_on} {
		ringlight
	}
}

#alias {on_mask_reclaimed}
{
	#if {$ringdark_on && $enemy[hp] > 10} {
		ringdark
	}
}

#nop HP[1952/2940] NP[57055/74600|1c] Grimare[100%/0c/21c] Memory[drm91]
#nop HP[2805/2805] NP[51518/74600|0c] Undead[none/19c] Memory[drm465]
#action {^{HP\[.+}} {process_hpbar {%0}}
#action {^{C:HP\[.+}} {process_hpbar {%0}}

#alias {process_hpbar}
{
	#nop allow mip to handle hp/sp updates, but only trigger off of NP values in this alias;

	#regexp {%1} {{NP\[(\d+)\/(\d+)\|(\d+)c\]}} {
		#var {my[gp1][current]}		{&2};
		#var {my[gp1][max]}			{&3};
		#var {corpses[inventory]}	{&4}
	};
	#regexp {%1} {{(?:\w+)\[(\d+)\%\/(\d+)c\/(\d+)c\]}} {
		#var {follower} {on};
		#var {corpses[follower]} {&3};
		#var {corpses[coffin]} {&4}
	} {
		#regexp {%1} {{Undead\[(?:\w+)\/(\d+)c\]}} {
			#var {follower} {off};
			#var {corpses[follower]} {0};
			#var {corpses[coffin]} {&2}
		}
	};
	#regexp {%1} {{(?:drm|alt|ssh)(\d+)}} {
		#var {my[powers][heal]} {&2}
	};

	#math {my[gp1][perc]} {$my[gp1][current] * 100 / $my[gp1][max]};
	update_status_bar;

	#if {$my[worth] < 125} {
		#math {con_amount} {(125-$my[worth]) * 20};
		#if {$con_amount > 200} {#variable con_amount 200};
		#send !con $con_amount
	};

	#if {"$my[prot]" == "OFF"} {
		#send !protection
	};

	#nop it's assumed the mask module is being used, even if there's no mask or it's turned off it still provides enhanced functionality;
	#if {($my[gp1][perc] < 50) && ($enemy[hp] > 5)} {
		#if {$recently_reclaimed == 0} {
			#if {$my[gp1][perc] <= 20} {
				#delay {reclaim} {mu 5} {0.1}
			};#elseif {$my[gp1][perc] <= 30} {
				#delay {reclaim} {mu 4} {0.1}
			};#elseif {$my[gp1][perc] <= 40} {
				#delay {reclaim} {mu 3} {0.1}
			};#else {
				#delay {reclaim} {mu 2} {0.1}
			}
		}
	};

	#nop only do automated guild runs if we are stepping;
	#if {$guildruns_on == 1 && $mip[round] > 0 && $bot == 1 && $halt == 0} {

		#nop check reagents - doante, stock and study if low;
		#if {$my[rg][ginseng] < 50 || $my[rg][goldenrod] < 50} {
			#echo {<258>---> Starting guild run for <158>reagents<258>.<088>};
			prep_guildrun
		};

		#nop check dreams remaining - doante, stock and study if low;
		#if {$nset[study_on] == 1 && $nset[heals_low] > 0 && $my[powers][heal] < $nset[heals_low]} {
			#echo {<258>---> Starting guild run for <158>dream/alter/shapeshift<258>.<088>};
			prep_guildrun
		};

		#nop check corpse count - doante, stock, store and study if overflowing;
		#if {$corpseruns_on == 1} {
			#nop check for corpse donate to guild;
			#if {($corpses[coffin] >= $nset[coffin_max]) && ("$freezer" != "on" || $corpses[freezer] >= 49) && ("$cooler" != "on" || $corpses[cooler] >= 49)} {
				#echo {<258>---> Starting guild run for <158>corpse drop-off<258>.<088>};
				prep_guildrun
			}
		};
		#elseif {$corpseruns_on == 2} {
			#nop check for corpse stashing (pickup or dropoffs);
			#if {($corpses[coffin] >= $nset[coffin_max]) && ("$freezer" != "on" || $corpses[freezer] >= 49) && ("$cooler" != "on" || $corpses[cooler] >= 49)} {
				#echo {<258>---> Starting guild run for <158>corpse-pickup<258>.<088>};
				#nop prep_guildrun
			}
		};

		#nop if the last con failed due to no coins, prep a guildrun;
		#if {$low_coins == 1} {
			#echo {<258>---> Starting guild run for <158>low coins<258>.<088>};
			prep_guildrun
		}
	};

	#if {$ipp_charge == 0} {
		update_cooldown prime 0;
	};

	#nop get the bot step position and length for displaying on the bottom bars;
	#path get length path_len;
	#path get position path_pos
}

#alias {prep_guildrun}
{
	#if {$halting == 0} {
		#variable halting 1;
		.stop;
		onk check_guildrun;
		#bell;
		#delay 1 #bell;
	}
}

#alias {check_guildrun}
{
	#delay {4} {
		#if {$mip[round] == 0} {
			onk clear;
			#variable halting 0;
			guildrun
		}
	}
}

#nop if a guildrun has been initiated, cancel it with this alias
#alias {cancel_guildrun}
{
	onk clear;
	#variable halting 0;
}

#alias {update_status}
{
	#nop do not perform any actions from update_status as mip data is unreliable and it this alias fires several times a round;
	#math {my[gp1][perc]} {$my[gp1][current] * 100 / $my[gp1][max]};
	#math {my[hp][perc]} {$my[hp][current] * 100 / $my[hp][max]};
	#math {my[sp][perc]} {$my[sp][current] * 100 / $my[sp][max]};

	#var {my[hp][graph]}	{@graph{$my[hp][current];$my[hp][max]}};
	#var {my[sp][graph]}	{@graph{$my[sp][current];$my[sp][max]}};
	#var {my[gp1][graph]}	{@graph{$my[gp1][current];$my[gp1][max]}};
	#var {enemy[graph]}		{@graph{$enemy[hp];100}};
	#format {hp}			{%+5s} {@colscale{$my[hp][current];$my[hp][max]}};
	#format {hp_max}		{%-5s} {<128>$my[hp][max]<088>};
	#format {sp}			{%+4s} {@colscale{$my[sp][current];$my[sp][max]}};
	#format {sp_inf}		{%+3s} {<168>$my[sp][fuse][current]<088>};
	#format {sp_max}		{%+4s} {<128>$my[sp][max]<088>};

	#math {np_k} 			{$my[gp1][current] / 1000};
	#math {np_max_k} 		{$my[gp1][max] / 1000};
	#format {np}			{%+3s${scol}k<088>} {@colscale{$np_k;$np_max_k}};
	#format {np_max}		{<128>%-4s<088>} {${np_max_k}${scol}k};

	#format {corpsestatus} {<eea>%s<088>/<aff>%s<088>/%s<088>/%s<088>/%s<088>} {$corpses[inventory]} {$corpses[coffin]} {@onoffnumbercolour{$freezer;<afc>;$corpses[freezer]}} {@onoffnumbercolour{$cooler;<acf>;$corpses[cooler]}} {@onoffnumbercolour{$follower;<eae>;$corpses[follower]}};
	#format {roundcount} {%s} {$mip[round]};
	#format {gstatus} {<088>%sC%sM%sS%s%s%sH%sR ${scol}[%sG%sC${scol}]<088>} {@statuscolour{$corpsetrig_on}} {@statuscolour{$mask_on}} {@statuscolour{$scalers_enabled}} {@statuscolour{$combat_que_on}} {$area_rating} {@statuscolour{$global_hardmode}} {@statuscolour{$ringdark_on}} {@statuscolour{$guildruns_on}} {@statuscolour{$corpseruns_on}};
	#format {botstatus} {%+3s/%-3s} {$path_pos} {$path_len};

	#if {$nset[study_on]} {
		#variable {powerstatus} { ${scol}DR:@colscale{$my[powers][dream];700}}
	} {
		#variable {powerstatus} {}
	};

	#line ignore #showme {${scol}HP:$hp/$hp_max ${scol}SP:$sp/$sp_max  ${scol}NP:$np/$np_max   ${scol}BS:<088>$botstatus    ${scol}DA:@colscale{$dmg[cur][rnd];10000}$powerstatus} {-4};
	#line ignore #showme {${scol}HP:$my[hp][graph]  ${scol}SP:$my[sp][graph] ${scol}NP:$my[gp1][graph]  ${scol}EH:$enemy[graph] ${scol}RC:<088>$roundcount} {-3};

	#if {$mip[round] == 0} {update_status_bar};
}

#nop updated primarily from the HP bar trigger, or when a mip update happens outside of combat
#alias {update_status_bar}
{
	#if {$nset[circle]} {
		#variable {circle_status} {${scol}CR:<258>$my[gxp]${scol}\% }
	} {
		#variable {circle_status} {}
	};
	#format {statusbar} {${scol}WO:%s${scol}\% ${scol}TP:%s ${scol}FG:%s ${scol}PR:%s ${scol}RP:%s${scol}\% ${circle_status}${scol}UF:%s${scol}\% ${scol}CC:$corpsestatus <088>$gstatus ${scol}(<add>%s${scol})<088> %s} {@colscale{$my[worth];120}} {@colscale{$my[ports][current];5}} {@colscale{$my[glamors][current];9}} {@onoffcolour{$my[prot]}} {@colscale{$my[repower];100}} {@colscale{$my[undead];100}} {$comtrance} {$onkill};
	#line ignore #showme {$statusbar} {-6};
}

#alias {corpsetrig}
{
	#if {$combat_que_on} {
		#nop unlock any comabt que abilities that are once per fight;
		cq refresh
	};
	#if {$corpsetrig_on} {
		#if {$nset[ktrig_on] == 0} {
			#nop ktrig is not being used, so handle it with qtrance here;
			#send !qtrance $ktrig
		};
		#if {$corpsetrig_on == 2} {#send !divvy coins} {#send !get coins};
		#if {$backpack_module} {stacknext} {#send !get all}
	} {
		#nop corpse trig off, send a divvy as it will unidle, and is semi useful;
		#send !divvy coins
	};
	#if {$onkill_module} {onkillrun};
	#if {$cocoon} {#send !fuse};
	#delay {3} {ktrigsetup}
}

/* Preserve all */
#variable preserving 0

#alias {mpp}
{
	#var preserving 1;
	#var preserve_np 0;
	#var preserve_done 0;
	qtrance preserve remains>20
}

#act {^You only have %d/%d necromantic points for that.} {
	#if {$preserving} {
		#var preserve_np 1
	}
}
#act {^That corpse is already preserved master.} {
	#if {$preserving} {
		#var preserve_done 1
	}
}
#act {^There is no corpse in this room master.} {
	#if {$preserving} {
		#var preserve_done 1
	}
}

#act {^You recover your senses} {
	#if {$preserving} {
		#if {$preserve_np} {
			absorb;
			mpp
		}; #elseif {$preserve_done} {
			#var preserving 0
		}; #else {
			mpp
		}
	}
}

#nop restock regents up to 999 each or $nset[bloodmoss] using mip data from cconfigure
#alias {stockall}
{
	#foreach {*my[rg][%*]} {reagent} {
		#local {tobuy} {};
		#local {maxstock} {999};
		#local {uom} {100};

		#if {"$reagent" == "bloodmoss"}
		{
			#variable {maxstock} {$nset[bloodmoss]};
			#variable {uom} {10}
		};

		#math {tobuy} {$maxstock - $my[rg][$reagent]};

		#while {$tobuy > 0}
		{
			#if {$tobuy > $uom}
			{
				#send {buy $uom $reagent}
			} {
				#send {buy $tobuy $reagent}
			};
			#math {tobuy} {$tobuy - $uom}
		}
	}
}

#nop Override the alias from mip.tin to suit the changed configuration - see header notes for more details
#alias {.mipProcessGlineNecromancer} {
	#if {%1 == 1} {
		#regexp {$mip[gline][1]} {C:%d}				{#VAR {corpses[inventory]} {&1}};
		#regexp {$mip[gline][1]} {Worth:%d}			{#VAR {my[worth]} {&1}};
		#regexp {$mip[gline][1]} {Tport:%d/%d}		{#VAR {my[ports][current]} {&1};#VAR {my[ports][max]} {&2}};
		#regexp {$mip[gline][1]} {Repower:%d}		{#VAR {my[repower]}	{&1}};
		#regexp {$mip[gline][1]} {{Prot:(ON|OFF)}}	{#VAR {my[prot]} {&2}};
		#regexp {$mip[gline][1]} {Circle:%d}		{#VAR {my[gxp]} {&1}};
		#regexp {$mip[gline][1]} {Undead:%d}		{#VAR {my[undead]} {&1}};
		#nop todo: check for other fuses;
		#regexp {$mip[gline][1]} {SPf:%d/%d}		{#VAR {my[sp][fuse][current]} {&1};#VAR {my[sp][fuse][max]}	{&2}};
		#nop todo: check for other form glamors;
		#regexp {$mip[gline][1]} {Sprk:%d/%d}		{#VAR {my[glamors][current]} {&1};#VAR {my[glamors][max]} {&2}}
	};
	#elseif {%1 == 2} {
		#regexp {$mip[gline][2]} {G:%d} {#VAR {my[rg][ginseng]} {&1}};
		#regexp {$mip[gline][2]} {P:%d} {#VAR {my[rg][black pearl]} {&1}};
		#regexp {$mip[gline][2]} {W:%d} {#VAR {my[rg][spider web]} {&1}};
		#regexp {$mip[gline][2]} {R:%d} {#VAR {my[rg][goldenrod]} {&1}};
		#regexp {$mip[gline][2]} {M:%d} {#VAR {my[rg][mandrake]} {&1}};
		#regexp {$mip[gline][2]} {N:%d} {#VAR {my[rg][pine needle]} {&1}};
		#regexp {$mip[gline][2]} {S:%d} {#VAR {my[rg][nightshade]} {&1}};
		#regexp {$mip[gline][2]} {B:%d} {#VAR {my[rg][bloodmoss]} {&1}}
	};
	#else {
		#ECHO {<171> Invalid Gline Number <088>}
	}
} {1}

#nop alias for configuring the npowers listing for automated power studying
#alias {npowers}
{
	#switch {"%1"} {
		#case "add" {
			#regexp {%0} {{add ([a-zA-Z\s]+) ([1-9][0-9]{0,2}) ([0-9]{1,6})}} {
				#local {cdname} {};
                #format {cdname} {%l} {&2};
				#if {"$cdname" == "diurnum"} {
					#nop always use the nocturnum variant of this power;
					#variable {cdname} {nocturnum};
					#echo {<258>Using nocturnum name variant instead.<088>}
				};
				#local {index} {@get_np_index{$cdname}};
                #if {$index != 0} {
                    #nop delete the existing entry and replace it;
                    #list {powerstudy} {delete} {$index}
                };
				#list {powerstudy} {add} {{{name}{$cdname}{quantity}{&3}{priority}{&4}}};
				#class {necropowerslist} {write} {.tt/char/$ses_name-necropowers.tin};
				#echo {<258>Power $cdname x &3 added, priority &4.<088>}
			} {
				#echo {<258>Syntax is 'npowers add <name> <quantity> <priority>'<088>}
			}
		};
		#case "remove" {
			#regexp {%0} {{remove ([a-zA-Z\s]+)}} {
				#local {cdname} {};
				#format {cdname} {%l} {&2};
				#local {index} {@get_np_index{$cdname}};
				#if {$index > 0} {
					#list {powerstudy} {delete} {$index};
					#echo {<258>Power &2 removed from npowers list.<088>}
				} {
					#echo {<258>That power is not on your npowers list.<088>}
				}
			} {
				#echo {<258>Syntax is 'npowers remove <name>'.<088>}
			}
		};
		#case "" {
			#local {header} {};
			#local {powerout} {};
            #format {powerout} {<158> Power                Qty Priority<088>} {$powerout};
			#format {powerout} {%s\n<258>-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-<088>} {$powerout};
			#if {&{powerstudy[]} == 0} {
				#format {powerout} {%s\n You have no configured powers to study} {$powerout}
			} {
				#list {powerstudy} {indexate} {priority};
				#list {powerstudy} {order};
				#nop #list {powerstudy} {reverse};
				#foreach {*powerstudy[%*]} {index} {
						#format {powerout} {%s\n %-20s %+3s %s} {$powerout} {$powerstudy[$index][name]} {$powerstudy[$index][quantity]} {$powerstudy[$index][priority]}
				};
			};
			#echo {$powerout}
		}
	}
}

#nop not used for anything currently
#action {^You currently have %1/%2 open memory globes}
{
	#variable {globes[open]} {%1};
	#variable {globes[max]} {%2};
}

#nop main alias to start the study process and capturing the curently studied quantities
#alias {studyall}
{
	#if {&{powerstudy[]} == 0} {
		#echo {<258>You have no configured powers to study, use the <158>npowers<258> command.<088>}
	} {
		#variable {studying} {1};
		#if {"%1" != ""} {
			#variable {studying} {2}
		};
		#nop    daemon graft(3):   3    9       di/nocturnum(3): 114  342;
		#action {{(?:[\s]+)(?:[a-z]+\/)?([a-z\s]+)\([0-9]\):[\s]+(\d+)[\s]+[\d]+((?:[\s]+)(?:[a-z]+\/)?([a-z\s]+)\([0-9]\):[\s]+(\d+))?}} {
			#variable {memory[%%2]} {%%3};
			#if {%%6} {
				#variable {memory[%%5]} {%%6}
			}
		};
		#nop show the powers page to scrape the data with the above action;
		#delay {0.5} {#send !powers}
	}
}

#nop triggered from the last line of the powers command to complete the process
#action {^For more on any power, type 'info <power>'}
{
	#unaction {{(?:[\s]+)(?:[a-z]+\/)?([a-z\s]+)\([0-9]\):[\s]+(\d+)[\s]+[\d]+((?:[\s]+)(?:[a-z]+\/)?([a-z\s]+)\([0-9]\):[\s]+(\d+))?}};

	#if {$studying} {
		_necstudy
	}
}

#alias {_necstudy}
{
	#list {powerstudy} {indexate} {priority};
	#list {powerstudy} {order};

	#foreach {*powerstudy[]} {index} {
		#local {name} {$powerstudy[$index][name]};
		#local {qty} {$powerstudy[$index][quantity]};
		#local {tostudy} {0};

		#if {$memory[$name]} {
			#if {$memory[$name] < $qty} {
				#math {tostudy} {$qty - $memory[$name]}
			} {
				#nop no studying necessary
			}
		} {
			#variable {tostudy} {$qty}
		};

		#while {$tostudy > 0} {
			#if {$tostudy > 100} {
				#send !study $name 100
			} {
				#send !study $name $tostudy
			};
			#math {tostudy} {$tostudy - 100}
		}
	};

	#if {$studying != 2} {
		#send !study LASTPOWER;
	};
	#variable {studying} {0}
}

#nop the study module attempts to study LASTPOWER, which fails and this action catches it and resumes movement
#action {^The power, LASTPOWER, does not exist}
{
	#nop head back to the RR from the form's library;
	#switch {"$nset[form]"} {
		#case "lich" {
			w;w;enter gate;u;s;s;sw;u;e;u;#5 e
		};
		#case "pure" {

		};
		#case "vampire" {

		};
		#case "were" {
			e;ne;path;se;se;d;n;nw;ne;ne;e;u;#5 e
		};
		#case "reaper" {

		};
		#default {
			n;#5 e
		}
	};
	#nop continue the guildrun;
	end_run
}

#function {get_np_index}
{
    #if {&{powerstudy[]} != 0} {
        #local {cdname} {};
        #format {cdname} {%l} {%1};
        #list {powerstudy} {indexate} {name};
        #list {powerstudy} {find} {$cdname} {result}
    } {
        #variable {result} {0}
    }
}

#class {necromancer} {close}
